(* Generated by re2ocaml 4.0.2 *)
(* $ make generate-re2c *)
(* vim: set filetype=ocaml: *)

open Parser

let sprintf = Printf.sprintf

type yycondtype = YYC_multi | YYC_single | YYC_rmulti | YYC_rsingle


type 'a state = {
  info : 'a;
  refill : 'a state -> bool;
  mutable reached_eof : bool;
  mutable absolute_offset : int; (* offset of current yyinput *)
  mutable yyinput : bytes;
  mutable yylimit : int;
  mutable yystart : int; (* automaton start *)
  mutable yycursor : int;
  mutable yyaccept : int;
  mutable yymarker : int;
  mutable yycond : yycondtype;
  
  mutable t1 : int;
  mutable t2 : int;
  mutable t3 : int;
  
  mutable yyt1 : int;
  mutable yyt2 : int;
}

type simple_state = unit state

let substr st l r = Bytes.sub_string st.yyinput l (r - l) [@@inline]

let make_state ~info ~refill ~limit input = {
  info;
  refill;
  reached_eof = false;
  absolute_offset = 0;
  yyinput = input;
  yylimit = limit;
  yycursor = 0;
  yystart = 0;
  yyaccept = 0;
  yymarker = 0;
  yycond = YYC_single;
  
  t1 = 0;
  t2 = 0;
  t3 = 0;
  
  yyt1 = 0;
  yyt2 = 0;
}

let state_of_string ~info str =
  let refill st = st.reached_eof <- true; false in
  let limit = String.length str in
  make_state ~info ~refill ~limit (Bytes.unsafe_of_string str)

type tokenizer_info = {
  (* filename *)
  fname : string;

  (* below, *lnum and *bol positions are absolute, whereas token_cnum (similar
     to yystart and yycursor) is relative to the current buffer *)

  (* line number and beginning of line offset for yycursor *)
  mutable lnum : int;
  mutable bol : int;

  (* same, for yystart. these are needed only in case error is raised from
     a semantic action *)
  mutable start_lnum : int;
  mutable start_bol : int;

  (* this indicates start of a (more high-level) token we're lexing *)
  mutable token_cnum : int;
  mutable token_lnum : int;
  mutable token_bol : int;

  strbuf : Buffer.t;
}

let make_tokenizer_info ?(fname = "") () =
  {
    fname;
    lnum = 1;
    bol = 0;
    start_lnum = 1;
    start_bol = 0;
    token_cnum = 0;
    token_lnum = 1;
    token_bol = 0;
    strbuf = Buffer.create 32;
  }

type tokenizer_state = tokenizer_info state

let make_refiller f =
  let min_avail = 1024 in
  let refill st =
    (* Bytes before the token start can be discarded *)
    let start = st.info.token_cnum in
    if st.reached_eof then false else begin
      if Bytes.length st.yyinput - start >= min_avail then
        (* Shift the buffer *)
        Bytes.blit st.yyinput start st.yyinput 0 (st.yylimit - start)
      else begin
        (* Too long token, grow the buffer *)
        let newlen = Int.min (Bytes.length st.yyinput lsl 1) Sys.max_string_length in
        if newlen <= Bytes.length st.yyinput then failwith "Cannot grow buffer";
        let newbuf = Bytes.create newlen in
        Bytes.blit st.yyinput start newbuf 0 (st.yylimit - start);
        st.yyinput <- newbuf;
      end;
      (* Update positions *)
      st.yycursor <- st.yycursor - start;
      st.yymarker <- st.yymarker - start;
      st.yylimit <- st.yylimit - start;
      st.yystart <- st.yystart - start;
      
  st.t1 <- st.t1 - start;
  st.t2 <- st.t2 - start;
  st.t3 <- st.t3 - start;
      
  st.yyt1 <- st.yyt1 - start;
  st.yyt2 <- st.yyt2 - start;
      st.info.token_cnum <- 0;
      st.absolute_offset <- st.absolute_offset + start;
      let read =
        let len = Bytes.length st.yyinput - st.yylimit in
        f st.yyinput ~offset:st.yylimit ~len
      in
      st.yylimit <- st.yylimit + read;
      if st.yylimit < Bytes.length st.yyinput then
        Bytes.unsafe_set st.yyinput st.yylimit '\x00';
      if read <= 0 then
        (st.reached_eof <- true; false)
      else true
    end
  in refill

let tokenizer_state_of_string ?fname str =
  state_of_string ~info:(make_tokenizer_info ?fname ()) str

let tokenizer_state_of_fun ?fname f =
  let len = 2048 in
  let refill = make_refiller f in
  let initial_buf = Bytes.create len in
  (* read initial chunk *)
  let limit = f initial_buf ~offset:0 ~len in
  if limit < len then Bytes.unsafe_set initial_buf limit '\x00';
  make_state ~info:(make_tokenizer_info ?fname ()) ~refill ~limit initial_buf

let tokenizer_state_of_channel ?fname ch =
  let f buf ~offset ~len = input ch buf offset len in
  tokenizer_state_of_fun ?fname f

let newline ?(pos = -2) st =
  let bol = if pos >= 0 then pos else st.yycursor in
  st.info.lnum <- st.info.lnum + 1;
  st.info.bol <- bol + st.absolute_offset

let save_start_position st =
  st.yystart <- st.yycursor;
  st.info.start_lnum <- st.info.lnum;
  st.info.start_bol <- st.info.bol
[@@inline]

let save_token_position st =
  st.info.token_cnum <- st.yycursor;
  st.info.token_lnum <- st.info.lnum;
  st.info.start_bol <- st.info.bol
[@@inline]

let make_lexing_token_pos st =
  Lexing.{
    pos_fname = st.info.fname;
    pos_lnum = st.info.token_lnum;
    pos_bol = st.info.token_bol;
    pos_cnum = st.info.token_cnum + st.absolute_offset;
  }

let make_lexing_start_pos st =
  Lexing.{
    pos_fname = st.info.fname;
    pos_lnum = st.info.start_lnum;
    pos_bol = st.info.start_bol;
    pos_cnum = st.yystart + st.absolute_offset;
  }

let make_lexing_end_pos st =
  Lexing.{
    pos_fname = st.info.fname;
    pos_lnum = st.info.lnum;
    pos_bol = st.info.bol;
    pos_cnum = st.yycursor + st.absolute_offset;
  }

let get_location st = make_lexing_token_pos st, make_lexing_end_pos st

let lexeme st = substr st st.yystart st.yycursor

let add_lexeme_to_buf st strbuf =
  let len = st.yycursor - st.yystart in
  Buffer.add_subbytes strbuf st.yyinput st.yystart len

let error st msg =
  let start_pos = make_lexing_start_pos st and end_pos = make_lexing_end_pos st in
  raise (Err.Custom_lexing_error (msg, (start_pos, end_pos)))

let malformed_utf8 st = error st "Malformed UTF-8"

(** Note: rollback can only be guaranteed to work if the previous data is still
    available, i.e., if we are still lexing the same token *)
let rollback_to_pos st (rollback_pos : Lexing.position) =
  let yycursor = rollback_pos.pos_cnum - st.absolute_offset in
  assert (yycursor >= 0);
  st.yycursor <- yycursor;
  st.info.bol <- rollback_pos.pos_bol;
  st.info.lnum <- rollback_pos.pos_lnum

(** Move yystart back to the start of the line *)
let rollback_start_to_newline st =
  st.yystart <- st.info.start_bol - st.absolute_offset

[@@@warning "-unused-var-strict"]

(* a bit dangerous, but disabled because of the conditionals codegen *)
[@@@warning "-partial-match"]




let rec yy0 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'
    | ','
    | ':'
    | '<'
    | '>'..'Z'
    | '^'..'e'
    | 'g'..'h'
    | 'j'..'m'
    | 'o'..'s'
    | 'u'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy3 [@tailcall]) st
    | '+' ->
      st.yycursor <- st.yycursor + 1;
      (yy6 [@tailcall]) st
    | '-' ->
      st.yycursor <- st.yycursor + 1;
      (yy7 [@tailcall]) st
    | '.' ->
      st.yycursor <- st.yycursor + 1;
      (yy8 [@tailcall]) st
    | 'f' ->
      st.yycursor <- st.yycursor + 1;
      (yy9 [@tailcall]) st
    | 'i' ->
      st.yycursor <- st.yycursor + 1;
      (yy10 [@tailcall]) st
    | 'n' ->
      st.yycursor <- st.yycursor + 1;
      (yy11 [@tailcall]) st
    | 't' ->
      st.yycursor <- st.yycursor + 1;
      (yy12 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy13 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy14 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy15 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy16 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy17 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy18 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy19 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy20 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy21 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy22 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy23 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy24 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy0 [@tailcall]) st
        else (yy54 [@tailcall]) st
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy1 [@tailcall]) st
      )

and yy1 (st : simple_state) : bool =
  (yy2 [@tailcall]) st

and yy2 (st : simple_state) : bool =
  false

and yy3 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  (yy4 [@tailcall]) st yych

and yy4 (st : simple_state) (yych : char) : bool =
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | '0'..':'
    | '<'
    | '>'..'Z'
    | '^'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy3 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy25 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy28 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy29 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy30 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy31 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy32 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy33 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy34 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy35 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy36 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy37 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy3 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )

and yy5 (st : simple_state) : bool =
  
    st.yycursor >= st.yylimit


and yy6 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '0'..'9' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy6 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | '.' ->
      st.yycursor <- st.yycursor + 1;
      (yy8 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy7 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '0'..'9' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy7 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | '.' ->
      st.yycursor <- st.yycursor + 1;
      (yy8 [@tailcall]) st
    | 'i' ->
      st.yycursor <- st.yycursor + 1;
      (yy10 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy8 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy8 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | '0'..'9' ->
      st.yycursor <- st.yycursor + 1;
      (yy38 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy9 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy9 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'a' ->
      st.yycursor <- st.yycursor + 1;
      (yy40 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy10 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy10 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'n' ->
      st.yycursor <- st.yycursor + 1;
      (yy41 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy11 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy11 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'a' ->
      st.yycursor <- st.yycursor + 1;
      (yy42 [@tailcall]) st
    | 'u' ->
      st.yycursor <- st.yycursor + 1;
      (yy43 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy12 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy12 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'r' ->
      st.yycursor <- st.yycursor + 1;
      (yy44 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy13 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy3 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy13 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy14 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy3 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy14 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy15 (st : simple_state) : bool =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy15 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy16 (st : simple_state) : bool =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy45 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy16 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy17 (st : simple_state) : bool =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy46 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy47 [@tailcall]) st
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy17 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy18 (st : simple_state) : bool =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy45 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy18 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy19 (st : simple_state) : bool =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy19 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy20 (st : simple_state) : bool =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy20 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy21 (st : simple_state) : bool =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy48 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy21 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy22 (st : simple_state) : bool =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy32 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy22 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy23 (st : simple_state) : bool =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy32 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy23 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy24 (st : simple_state) : bool =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy32 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy24 [@tailcall]) st
        else (yy2 [@tailcall]) st
      ) else (
        (yy2 [@tailcall]) st
      )

and yy25 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy3 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy25 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy26 (st : simple_state) : bool =
  st.yycursor <- st.yymarker;
  match st.yyaccept with
    | 0 -> (yy5 [@tailcall]) st
    | 1 -> (yy2 [@tailcall]) st
    | 2 -> (yy39 [@tailcall]) st
    | _ -> (yy51 [@tailcall]) st

and yy27 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy3 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy27 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy28 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy28 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy29 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy45 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy29 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy30 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy46 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy47 [@tailcall]) st
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy30 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy31 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy45 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy31 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy32 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy32 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy33 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy33 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy34 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy27 [@tailcall]) st
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy48 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy34 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy35 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy32 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy35 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy36 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy32 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy36 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy37 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy32 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy37 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy38 (st : simple_state) : bool =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | '0'..':'
    | '<'
    | '>'..'Z'
    | '^'..'z'
    | '|'
    | '~'
    | '\xC2'..'\xF4' -> (yy4 [@tailcall]) st yych
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy38 [@tailcall]) st
        else (yy39 [@tailcall]) st
      ) else (
        (yy39 [@tailcall]) st
      )

and yy39 (st : simple_state) : bool =
  false

and yy40 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy40 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'l' ->
      st.yycursor <- st.yycursor + 1;
      (yy49 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy41 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy41 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'f' ->
      st.yycursor <- st.yycursor + 1;
      (yy50 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy42 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy42 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'n' ->
      st.yycursor <- st.yycursor + 1;
      (yy50 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy43 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy43 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'l' ->
      st.yycursor <- st.yycursor + 1;
      (yy52 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy44 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy44 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'u' ->
      st.yycursor <- st.yycursor + 1;
      (yy53 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy45 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy3 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy45 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy46 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x8B'..'\x8D'
    | '\x90'..'\xA7'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy3 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy46 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy47 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy3 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy47 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy48 (st : simple_state) : bool =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy3 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy48 [@tailcall]) st
        else (yy26 [@tailcall]) st
      ) else (
        (yy26 [@tailcall]) st
      )

and yy49 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy49 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 's' ->
      st.yycursor <- st.yycursor + 1;
      (yy53 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy50 (st : simple_state) : bool =
  st.yyaccept <- 3;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | '0'..':'
    | '<'
    | '>'..'Z'
    | '^'..'z'
    | '|'
    | '~'
    | '\xC2'..'\xF4' -> (yy4 [@tailcall]) st yych
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy50 [@tailcall]) st
        else (yy51 [@tailcall]) st
      ) else (
        (yy51 [@tailcall]) st
      )

and yy51 (st : simple_state) : bool =
  
    not (st.yycursor >= st.yylimit)


and yy52 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy52 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'l' ->
      st.yycursor <- st.yycursor + 1;
      (yy50 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy53 (st : simple_state) : bool =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy53 [@tailcall]) st
        else (yy5 [@tailcall]) st
      ) else (
        (yy5 [@tailcall]) st
      )
    | 'e' ->
      st.yycursor <- st.yycursor + 1;
      (yy50 [@tailcall]) st
    | _ -> (yy4 [@tailcall]) st yych

and yy54 (st : simple_state) : bool =
  false

and is_valid_ident (st : simple_state) : bool =
  (yy0 [@tailcall]) st




let rec yy55 (st : simple_state) (strbuf : Buffer.t) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\x07'
    | '\x0E'..'\x1F'
    | '\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy55 [@tailcall]) st strbuf
        else (yy82 [@tailcall]) st strbuf
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy56 [@tailcall]) st strbuf
      )
    | '\b' ->
      st.yycursor <- st.yycursor + 1;
      (yy57 [@tailcall]) st strbuf
    | '\t' ->
      st.yycursor <- st.yycursor + 1;
      (yy58 [@tailcall]) st strbuf
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy59 [@tailcall]) st strbuf
    | '\x0B'
    | ' '..'!'
    | '#'..'['
    | ']'..'~' ->
      st.yycursor <- st.yycursor + 1;
      (yy60 [@tailcall]) st strbuf
    | '\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy61 [@tailcall]) st strbuf
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy62 [@tailcall]) st strbuf
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy63 [@tailcall]) st strbuf
    | '\\' ->
      st.yycursor <- st.yycursor + 1;
      (yy64 [@tailcall]) st strbuf
    | '\xC2'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy67 [@tailcall]) st strbuf
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy68 [@tailcall]) st strbuf
    | '\xE1'
    | '\xE3'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy69 [@tailcall]) st strbuf
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy70 [@tailcall]) st strbuf
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy71 [@tailcall]) st strbuf
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy72 [@tailcall]) st strbuf
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy73 [@tailcall]) st strbuf
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy74 [@tailcall]) st strbuf
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy75 [@tailcall]) st strbuf
    | _ ->
      st.yycursor <- st.yycursor + 1;
      (yy65 [@tailcall]) st strbuf

and yy56 (st : simple_state) (strbuf : Buffer.t) : string =
  
    let udecode = Bytes.get_utf_8_uchar st.yyinput st.yystart in
    if not (Uchar.utf_decode_is_valid udecode) then
      failwith "Malformed UTF-8";
    let code = Uchar.to_int (Uchar.utf_decode_uchar udecode) in
    Buffer.add_string strbuf (Printf.sprintf "\\u{%X}" code);
    escape_string st strbuf


and yy57 (st : simple_state) (strbuf : Buffer.t) : string =
  Buffer.add_string strbuf "\\b"; escape_string st strbuf

and yy58 (st : simple_state) (strbuf : Buffer.t) : string =
  Buffer.add_string strbuf "\\t"; escape_string st strbuf

and yy59 (st : simple_state) (strbuf : Buffer.t) : string =
  Buffer.add_string strbuf "\\n"; escape_string st strbuf

and yy60 (st : simple_state) (strbuf : Buffer.t) : string =
  
    add_lexeme_to_buf st strbuf;
    escape_string st strbuf


and yy61 (st : simple_state) (strbuf : Buffer.t) : string =
  Buffer.add_string strbuf "\\f"; escape_string st strbuf

and yy62 (st : simple_state) (strbuf : Buffer.t) : string =
  Buffer.add_string strbuf "\\r"; escape_string st strbuf

and yy63 (st : simple_state) (strbuf : Buffer.t) : string =
  Buffer.add_string strbuf "\\\""; escape_string st strbuf

and yy64 (st : simple_state) (strbuf : Buffer.t) : string =
  Buffer.add_string strbuf "\\\\"; escape_string st strbuf

and yy65 (st : simple_state) (strbuf : Buffer.t) : string =
  (yy66 [@tailcall]) st strbuf

and yy66 (st : simple_state) (strbuf : Buffer.t) : string =
  failwith "Malformed UTF-8"

and yy67 (st : simple_state) (strbuf : Buffer.t) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy60 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy67 [@tailcall]) st strbuf
        else (yy66 [@tailcall]) st strbuf
      ) else (
        (yy66 [@tailcall]) st strbuf
      )

and yy68 (st : simple_state) (strbuf : Buffer.t) : string =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy76 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy68 [@tailcall]) st strbuf
        else (yy66 [@tailcall]) st strbuf
      ) else (
        (yy66 [@tailcall]) st strbuf
      )

and yy69 (st : simple_state) (strbuf : Buffer.t) : string =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy76 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy69 [@tailcall]) st strbuf
        else (yy66 [@tailcall]) st strbuf
      ) else (
        (yy66 [@tailcall]) st strbuf
      )

and yy70 (st : simple_state) (strbuf : Buffer.t) : string =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy78 [@tailcall]) st strbuf
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy79 [@tailcall]) st strbuf
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy76 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy70 [@tailcall]) st strbuf
        else (yy66 [@tailcall]) st strbuf
      ) else (
        (yy66 [@tailcall]) st strbuf
      )

and yy71 (st : simple_state) (strbuf : Buffer.t) : string =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy76 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy71 [@tailcall]) st strbuf
        else (yy66 [@tailcall]) st strbuf
      ) else (
        (yy66 [@tailcall]) st strbuf
      )

and yy72 (st : simple_state) (strbuf : Buffer.t) : string =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy76 [@tailcall]) st strbuf
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy80 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy72 [@tailcall]) st strbuf
        else (yy66 [@tailcall]) st strbuf
      ) else (
        (yy66 [@tailcall]) st strbuf
      )

and yy73 (st : simple_state) (strbuf : Buffer.t) : string =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy81 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy73 [@tailcall]) st strbuf
        else (yy66 [@tailcall]) st strbuf
      ) else (
        (yy66 [@tailcall]) st strbuf
      )

and yy74 (st : simple_state) (strbuf : Buffer.t) : string =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy81 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy74 [@tailcall]) st strbuf
        else (yy66 [@tailcall]) st strbuf
      ) else (
        (yy66 [@tailcall]) st strbuf
      )

and yy75 (st : simple_state) (strbuf : Buffer.t) : string =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy81 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy75 [@tailcall]) st strbuf
        else (yy66 [@tailcall]) st strbuf
      ) else (
        (yy66 [@tailcall]) st strbuf
      )

and yy76 (st : simple_state) (strbuf : Buffer.t) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy60 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy76 [@tailcall]) st strbuf
        else (yy77 [@tailcall]) st strbuf
      ) else (
        (yy77 [@tailcall]) st strbuf
      )

and yy77 (st : simple_state) (strbuf : Buffer.t) : string =
  st.yycursor <- st.yymarker;
  (yy66 [@tailcall]) st strbuf

and yy78 (st : simple_state) (strbuf : Buffer.t) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8D'
    | '\x90'..'\xA9'
    | '\xAF'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy60 [@tailcall]) st strbuf
    | '\x8E'..'\x8F'
    | '\xAA'..'\xAE' ->
      st.yycursor <- st.yycursor + 1;
      (yy56 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy78 [@tailcall]) st strbuf
        else (yy77 [@tailcall]) st strbuf
      ) else (
        (yy77 [@tailcall]) st strbuf
      )

and yy79 (st : simple_state) (strbuf : Buffer.t) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy60 [@tailcall]) st strbuf
    | '\xA6'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy56 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy79 [@tailcall]) st strbuf
        else (yy77 [@tailcall]) st strbuf
      ) else (
        (yy77 [@tailcall]) st strbuf
      )

and yy80 (st : simple_state) (strbuf : Buffer.t) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy60 [@tailcall]) st strbuf
    | '\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy56 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy80 [@tailcall]) st strbuf
        else (yy77 [@tailcall]) st strbuf
      ) else (
        (yy77 [@tailcall]) st strbuf
      )

and yy81 (st : simple_state) (strbuf : Buffer.t) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy76 [@tailcall]) st strbuf
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy81 [@tailcall]) st strbuf
        else (yy77 [@tailcall]) st strbuf
      ) else (
        (yy77 [@tailcall]) st strbuf
      )

and yy82 (st : simple_state) (strbuf : Buffer.t) : string =
  Buffer.contents strbuf

and escape_string_body (st : simple_state) (strbuf : Buffer.t) : string =
  (yy55 [@tailcall]) st strbuf



and escape_string st strbuf =
  st.yystart <- st.yycursor;
  escape_string_body st strbuf

let is_valid_ident str =
  is_valid_ident (state_of_string ~info:() str) [@@inline]

let escape_string = function
  | "" as empty -> empty
  | str -> escape_string (state_of_string ~info:() str) (Buffer.create 32)

(* Tokenizer *)


let rec yy83 (st : tokenizer_state) (depth : int) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\t'
    | '\x0E'..')'
    | '+'..'.'
    | '0'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy83 [@tailcall]) st depth
        else (yy108 [@tailcall]) st depth
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy84 [@tailcall]) st depth
      )
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy86 [@tailcall]) st depth
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy88 [@tailcall]) st depth
    | '*' ->
      st.yycursor <- st.yycursor + 1;
      (yy89 [@tailcall]) st depth
    | '/' ->
      st.yycursor <- st.yycursor + 1;
      (yy90 [@tailcall]) st depth
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy93 [@tailcall]) st depth
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy94 [@tailcall]) st depth
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy95 [@tailcall]) st depth
    | '\xE1'
    | '\xE3'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy96 [@tailcall]) st depth
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy97 [@tailcall]) st depth
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy98 [@tailcall]) st depth
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy99 [@tailcall]) st depth
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy100 [@tailcall]) st depth
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy101 [@tailcall]) st depth
    | _ ->
      st.yycursor <- st.yycursor + 1;
      (yy91 [@tailcall]) st depth

and yy84 (st : tokenizer_state) (depth : int) : unit =
  (yy85 [@tailcall]) st depth

and yy85 (st : tokenizer_state) (depth : int) : unit =
  multiline_comment st depth

and yy86 (st : tokenizer_state) (depth : int) : unit =
  (yy87 [@tailcall]) st depth

and yy87 (st : tokenizer_state) (depth : int) : unit =
  newline st; multiline_comment st depth

and yy88 (st : tokenizer_state) (depth : int) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy86 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy88 [@tailcall]) st depth
        else (yy87 [@tailcall]) st depth
      ) else (
        (yy87 [@tailcall]) st depth
      )

and yy89 (st : tokenizer_state) (depth : int) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '/' ->
      st.yycursor <- st.yycursor + 1;
      (yy102 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy89 [@tailcall]) st depth
        else (yy85 [@tailcall]) st depth
      ) else (
        (yy85 [@tailcall]) st depth
      )

and yy90 (st : tokenizer_state) (depth : int) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '*' ->
      st.yycursor <- st.yycursor + 1;
      (yy103 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy90 [@tailcall]) st depth
        else (yy85 [@tailcall]) st depth
      ) else (
        (yy85 [@tailcall]) st depth
      )

and yy91 (st : tokenizer_state) (depth : int) : unit =
  (yy92 [@tailcall]) st depth

and yy92 (st : tokenizer_state) (depth : int) : unit =
  malformed_utf8 st

and yy93 (st : tokenizer_state) (depth : int) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy84 [@tailcall]) st depth
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy86 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy93 [@tailcall]) st depth
        else (yy92 [@tailcall]) st depth
      ) else (
        (yy92 [@tailcall]) st depth
      )

and yy94 (st : tokenizer_state) (depth : int) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy84 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy94 [@tailcall]) st depth
        else (yy92 [@tailcall]) st depth
      ) else (
        (yy92 [@tailcall]) st depth
      )

and yy95 (st : tokenizer_state) (depth : int) : unit =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy104 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy95 [@tailcall]) st depth
        else (yy92 [@tailcall]) st depth
      ) else (
        (yy92 [@tailcall]) st depth
      )

and yy96 (st : tokenizer_state) (depth : int) : unit =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy104 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy96 [@tailcall]) st depth
        else (yy92 [@tailcall]) st depth
      ) else (
        (yy92 [@tailcall]) st depth
      )

and yy97 (st : tokenizer_state) (depth : int) : unit =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy106 [@tailcall]) st depth
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy104 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy97 [@tailcall]) st depth
        else (yy92 [@tailcall]) st depth
      ) else (
        (yy92 [@tailcall]) st depth
      )

and yy98 (st : tokenizer_state) (depth : int) : unit =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy104 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy98 [@tailcall]) st depth
        else (yy92 [@tailcall]) st depth
      ) else (
        (yy92 [@tailcall]) st depth
      )

and yy99 (st : tokenizer_state) (depth : int) : unit =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy107 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy99 [@tailcall]) st depth
        else (yy92 [@tailcall]) st depth
      ) else (
        (yy92 [@tailcall]) st depth
      )

and yy100 (st : tokenizer_state) (depth : int) : unit =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy107 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy100 [@tailcall]) st depth
        else (yy92 [@tailcall]) st depth
      ) else (
        (yy92 [@tailcall]) st depth
      )

and yy101 (st : tokenizer_state) (depth : int) : unit =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy107 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy101 [@tailcall]) st depth
        else (yy92 [@tailcall]) st depth
      ) else (
        (yy92 [@tailcall]) st depth
      )

and yy102 (st : tokenizer_state) (depth : int) : unit =
  if depth <= 0 then () else multiline_comment st (depth - 1)

and yy103 (st : tokenizer_state) (depth : int) : unit =
  multiline_comment st (depth + 1)

and yy104 (st : tokenizer_state) (depth : int) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy84 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy104 [@tailcall]) st depth
        else (yy105 [@tailcall]) st depth
      ) else (
        (yy105 [@tailcall]) st depth
      )

and yy105 (st : tokenizer_state) (depth : int) : unit =
  st.yycursor <- st.yymarker;
  (yy92 [@tailcall]) st depth

and yy106 (st : tokenizer_state) (depth : int) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xA7'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy84 [@tailcall]) st depth
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy86 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy106 [@tailcall]) st depth
        else (yy105 [@tailcall]) st depth
      ) else (
        (yy105 [@tailcall]) st depth
      )

and yy107 (st : tokenizer_state) (depth : int) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy104 [@tailcall]) st depth
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy107 [@tailcall]) st depth
        else (yy105 [@tailcall]) st depth
      ) else (
        (yy105 [@tailcall]) st depth
      )

and yy108 (st : tokenizer_state) (depth : int) : unit =
  error st "Unterminated comment"

and multiline_comment (st : tokenizer_state) (depth : int) : unit =
  (yy83 [@tailcall]) st depth




let rec yy109 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\t'
    | '\x0E'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy109 [@tailcall]) st
        else (yy138 [@tailcall]) st
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy110 [@tailcall]) st
      )
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy112 [@tailcall]) st
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy114 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy117 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy118 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy119 [@tailcall]) st
    | '\xE1'
    | '\xE3'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy120 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy121 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy122 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy123 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy124 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy125 [@tailcall]) st
    | _ ->
      st.yycursor <- st.yycursor + 1;
      (yy115 [@tailcall]) st

and yy110 (st : tokenizer_state) : unit =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\t'
    | '\x0E'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy110 [@tailcall]) st
        else (yy111 [@tailcall]) st
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy110 [@tailcall]) st
      )
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy126 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy128 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy129 [@tailcall]) st
    | '\xE1'
    | '\xE3'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy130 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy131 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy132 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy133 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy134 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy135 [@tailcall]) st
    | _ -> (yy111 [@tailcall]) st

and yy111 (st : tokenizer_state) : unit =
  singleline_comment st

and yy112 (st : tokenizer_state) : unit =
  (yy113 [@tailcall]) st

and yy113 (st : tokenizer_state) : unit =
  newline st

and yy114 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy112 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy114 [@tailcall]) st
        else (yy113 [@tailcall]) st
      ) else (
        (yy113 [@tailcall]) st
      )

and yy115 (st : tokenizer_state) : unit =
  (yy116 [@tailcall]) st

and yy116 (st : tokenizer_state) : unit =
  malformed_utf8 st

and yy117 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy110 [@tailcall]) st
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy112 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy117 [@tailcall]) st
        else (yy116 [@tailcall]) st
      ) else (
        (yy116 [@tailcall]) st
      )

and yy118 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy110 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy118 [@tailcall]) st
        else (yy116 [@tailcall]) st
      ) else (
        (yy116 [@tailcall]) st
      )

and yy119 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy128 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy119 [@tailcall]) st
        else (yy116 [@tailcall]) st
      ) else (
        (yy116 [@tailcall]) st
      )

and yy120 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy128 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy120 [@tailcall]) st
        else (yy116 [@tailcall]) st
      ) else (
        (yy116 [@tailcall]) st
      )

and yy121 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy136 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy128 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy121 [@tailcall]) st
        else (yy116 [@tailcall]) st
      ) else (
        (yy116 [@tailcall]) st
      )

and yy122 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy128 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy122 [@tailcall]) st
        else (yy116 [@tailcall]) st
      ) else (
        (yy116 [@tailcall]) st
      )

and yy123 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy130 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy123 [@tailcall]) st
        else (yy116 [@tailcall]) st
      ) else (
        (yy116 [@tailcall]) st
      )

and yy124 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy130 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy124 [@tailcall]) st
        else (yy116 [@tailcall]) st
      ) else (
        (yy116 [@tailcall]) st
      )

and yy125 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy130 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy125 [@tailcall]) st
        else (yy116 [@tailcall]) st
      ) else (
        (yy116 [@tailcall]) st
      )

and yy126 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy110 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy126 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy127 (st : tokenizer_state) : unit =
  st.yycursor <- st.yymarker;
  if (st.yyaccept == 0) then (yy111 [@tailcall]) st
  else (yy116 [@tailcall]) st

and yy128 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy110 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy128 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy129 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy128 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy129 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy130 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy128 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy130 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy131 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy137 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy128 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy131 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy132 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy128 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy132 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy133 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy130 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy133 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy134 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy130 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy134 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy135 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy130 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy135 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy136 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xA7'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy110 [@tailcall]) st
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy112 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy136 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy137 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xA7'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy110 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy137 [@tailcall]) st
        else (yy127 [@tailcall]) st
      ) else (
        (yy127 [@tailcall]) st
      )

and yy138 (st : tokenizer_state) : unit =
  ()

and singleline_comment (st : tokenizer_state) : unit =
  (yy109 [@tailcall]) st




let rec yy139 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'..'.'
    | '0'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy139 [@tailcall]) st
        else (yy176 [@tailcall]) st
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy140 [@tailcall]) st
      )
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy142 [@tailcall]) st
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy144 [@tailcall]) st
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy146 [@tailcall]) st
    | '/' ->
      st.yycursor <- st.yycursor + 1;
      (yy147 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy150 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy151 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy152 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy153 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy154 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy155 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy156 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy157 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy158 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy159 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy160 [@tailcall]) st
    | _ ->
      st.yycursor <- st.yycursor + 1;
      (yy148 [@tailcall]) st

and yy140 (st : tokenizer_state) : unit =
  (yy141 [@tailcall]) st

and yy141 (st : tokenizer_state) : unit =
  
    error st @@
      sprintf "Illegal character '%s' after the '\\' line continuation" (lexeme st)


and yy142 (st : tokenizer_state) : unit =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy142 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy161 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy163 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy164 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy165 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy142 [@tailcall]) st
        else (yy143 [@tailcall]) st
      ) else (
        (yy143 [@tailcall]) st
      )

and yy143 (st : tokenizer_state) : unit =
  line_cont st

and yy144 (st : tokenizer_state) : unit =
  (yy145 [@tailcall]) st

and yy145 (st : tokenizer_state) : unit =
  newline st

and yy146 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy144 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy146 [@tailcall]) st
        else (yy145 [@tailcall]) st
      ) else (
        (yy145 [@tailcall]) st
      )

and yy147 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '*' ->
      st.yycursor <- st.yycursor + 1;
      (yy166 [@tailcall]) st
    | '/' ->
      st.yycursor <- st.yycursor + 1;
      (yy167 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy147 [@tailcall]) st
        else (yy141 [@tailcall]) st
      ) else (
        (yy141 [@tailcall]) st
      )

and yy148 (st : tokenizer_state) : unit =
  (yy149 [@tailcall]) st

and yy149 (st : tokenizer_state) : unit =
  malformed_utf8 st

and yy150 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy140 [@tailcall]) st
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy144 [@tailcall]) st
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy142 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy150 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy151 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy140 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy151 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy152 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy168 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy152 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy153 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy168 [@tailcall]) st
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy169 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy153 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy154 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy170 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy171 [@tailcall]) st
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy168 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy154 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy155 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy169 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy168 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy155 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy156 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy168 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy156 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy157 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy168 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy157 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy158 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy172 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy158 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy159 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy172 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy159 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy160 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy172 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy160 [@tailcall]) st
        else (yy149 [@tailcall]) st
      ) else (
        (yy149 [@tailcall]) st
      )

and yy161 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy142 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy161 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy162 (st : tokenizer_state) : unit =
  st.yycursor <- st.yymarker;
  if (st.yyaccept == 0) then (yy143 [@tailcall]) st
  else (yy149 [@tailcall]) st

and yy163 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy173 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy163 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy164 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy174 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy175 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy164 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy165 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy173 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy165 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy166 (st : tokenizer_state) : unit =
  multiline_comment st 0; line_cont st

and yy167 (st : tokenizer_state) : unit =
  singleline_comment st

and yy168 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy140 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy168 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy169 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy142 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy140 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy169 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy170 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy142 [@tailcall]) st
    | '\x8B'..'\xA7'
    | '\xAA'..'\xAE'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy140 [@tailcall]) st
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy144 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy170 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy171 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy140 [@tailcall]) st
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy142 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy171 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy172 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy168 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy172 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy173 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy142 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy173 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy174 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy142 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy174 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy175 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy142 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy175 [@tailcall]) st
        else (yy162 [@tailcall]) st
      ) else (
        (yy162 [@tailcall]) st
      )

and yy176 (st : tokenizer_state) : unit =
  ()

and line_cont_body (st : tokenizer_state) : unit =
  (yy139 [@tailcall]) st



and line_cont st = save_start_position st; line_cont_body st


let rec yy177 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy177 [@tailcall]) st
        else (yy210 [@tailcall]) st
      ) else (
        st.yyt1 <- st.yycursor;
        st.yycursor <- st.yycursor + 1;
        (yy178 [@tailcall]) st
      )
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy179 [@tailcall]) st
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy181 [@tailcall]) st
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy183 [@tailcall]) st
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy186 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy187 [@tailcall]) st
    | '\xE0' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy188 [@tailcall]) st
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy189 [@tailcall]) st
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy190 [@tailcall]) st
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy191 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy192 [@tailcall]) st
    | '\xED' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy193 [@tailcall]) st
    | '\xF0' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy194 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy195 [@tailcall]) st
    | '\xF4' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy196 [@tailcall]) st
    | _ ->
      st.yycursor <- st.yycursor + 1;
      (yy184 [@tailcall]) st

and yy178 (st : tokenizer_state) : unit =
  st.yycursor <- st.yyt1;
  ()

and yy179 (st : tokenizer_state) : unit =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy179 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy197 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy199 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy200 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy201 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy179 [@tailcall]) st
        else (yy180 [@tailcall]) st
      ) else (
        (yy180 [@tailcall]) st
      )

and yy180 (st : tokenizer_state) : unit =
  whitespace_escape st

and yy181 (st : tokenizer_state) : unit =
  (yy182 [@tailcall]) st

and yy182 (st : tokenizer_state) : unit =
  newline st; whitespace_escape st

and yy183 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy181 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy183 [@tailcall]) st
        else (yy182 [@tailcall]) st
      ) else (
        (yy182 [@tailcall]) st
      )

and yy184 (st : tokenizer_state) : unit =
  (yy185 [@tailcall]) st

and yy185 (st : tokenizer_state) : unit =
  malformed_utf8 st

and yy186 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy178 [@tailcall]) st
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy181 [@tailcall]) st
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy179 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy186 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy187 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy178 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy187 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy188 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy202 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy188 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy189 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy202 [@tailcall]) st
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy203 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy189 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy190 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy204 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy205 [@tailcall]) st
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy202 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy190 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy191 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy203 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy202 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy191 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy192 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy202 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy192 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy193 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy202 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy193 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy194 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy206 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy194 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy195 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy206 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy195 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy196 (st : tokenizer_state) : unit =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy206 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy196 [@tailcall]) st
        else (yy185 [@tailcall]) st
      ) else (
        (yy185 [@tailcall]) st
      )

and yy197 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy179 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy197 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy198 (st : tokenizer_state) : unit =
  st.yycursor <- st.yymarker;
  if (st.yyaccept == 0) then (yy180 [@tailcall]) st
  else (yy185 [@tailcall]) st

and yy199 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy207 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy199 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy200 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy208 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy209 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy200 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy201 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy207 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy201 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy202 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy178 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy202 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy203 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy179 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy178 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy203 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy204 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy179 [@tailcall]) st
    | '\x8B'..'\xA7'
    | '\xAA'..'\xAE'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy178 [@tailcall]) st
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy181 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy204 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy205 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy178 [@tailcall]) st
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy179 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy205 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy206 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy202 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy206 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy207 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy179 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy207 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy208 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy179 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy208 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy209 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy179 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy209 [@tailcall]) st
        else (yy198 [@tailcall]) st
      ) else (
        (yy198 [@tailcall]) st
      )

and yy210 (st : tokenizer_state) : unit =
  ()

and whitespace_escape (st : tokenizer_state) : unit =
  (yy177 [@tailcall]) st




let rec yy211 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n'..'\x0C' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy214 [@tailcall]) st
    | '\r' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy216 [@tailcall]) st
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy217 [@tailcall]) st
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy218 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy211 [@tailcall]) st
        else (yy221 [@tailcall]) st
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy212 [@tailcall]) st
      )

and yy212 (st : tokenizer_state) : unit =
  (yy213 [@tailcall]) st

and yy213 (st : tokenizer_state) : unit =
  error st "A multiline string must start with newline"

and yy214 (st : tokenizer_state) : unit =
  (yy215 [@tailcall]) st

and yy215 (st : tokenizer_state) : unit =
  st.yycursor <- st.yyt1;
  ()

and yy216 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy214 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy216 [@tailcall]) st
        else (yy215 [@tailcall]) st
      ) else (
        (yy215 [@tailcall]) st
      )

and yy217 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy214 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy217 [@tailcall]) st
        else (yy213 [@tailcall]) st
      ) else (
        (yy213 [@tailcall]) st
      )

and yy218 (st : tokenizer_state) : unit =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy219 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy218 [@tailcall]) st
        else (yy213 [@tailcall]) st
      ) else (
        (yy213 [@tailcall]) st
      )

and yy219 (st : tokenizer_state) : unit =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy214 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy219 [@tailcall]) st
        else (yy220 [@tailcall]) st
      ) else (
        (yy220 [@tailcall]) st
      )

and yy220 (st : tokenizer_state) : unit =
  st.yycursor <- st.yymarker;
  (yy213 [@tailcall]) st

and yy221 (st : tokenizer_state) : unit =
  error st "A multiline string must start with newline"

and validate_multiline_start (st : tokenizer_state) : unit =
  (yy211 [@tailcall]) st



let validate_multiline_start st =
  save_start_position st;
  validate_multiline_start st


let rec yy222 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy225 [@tailcall]) st rollback_pos
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy227 [@tailcall]) st rollback_pos
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy228 [@tailcall]) st rollback_pos
    | '\\' ->
      st.yycursor <- st.yycursor + 1;
      (yy229 [@tailcall]) st rollback_pos
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy230 [@tailcall]) st rollback_pos
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy231 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy222 [@tailcall]) st rollback_pos
        else (yy273 [@tailcall]) st rollback_pos
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy223 [@tailcall]) st rollback_pos
      )

and yy223 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  (yy224 [@tailcall]) st rollback_pos

and yy224 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  detect_multiline_string_prefix st rollback_pos

and yy225 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy232 [@tailcall]) st rollback_pos
    | '"' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy234 [@tailcall]) st rollback_pos
    | '\\' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy235 [@tailcall]) st rollback_pos
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy236 [@tailcall]) st rollback_pos
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy237 [@tailcall]) st rollback_pos
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy238 [@tailcall]) st rollback_pos
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy239 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy225 [@tailcall]) st rollback_pos
        else (yy226 [@tailcall]) st rollback_pos
      ) else (
        (yy226 [@tailcall]) st rollback_pos
      )

and yy226 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  newline st; detect_multiline_string_prefix st rollback_pos

and yy227 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy232 [@tailcall]) st rollback_pos
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy225 [@tailcall]) st rollback_pos
    | '"' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy234 [@tailcall]) st rollback_pos
    | '\\' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy235 [@tailcall]) st rollback_pos
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy236 [@tailcall]) st rollback_pos
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy237 [@tailcall]) st rollback_pos
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy238 [@tailcall]) st rollback_pos
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy239 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy227 [@tailcall]) st rollback_pos
        else (yy226 [@tailcall]) st rollback_pos
      ) else (
        (yy226 [@tailcall]) st rollback_pos
      )

and yy228 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy240 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy228 [@tailcall]) st rollback_pos
        else (yy224 [@tailcall]) st rollback_pos
      ) else (
        (yy224 [@tailcall]) st rollback_pos
      )

and yy229 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy241 [@tailcall]) st rollback_pos
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy243 [@tailcall]) st rollback_pos
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy245 [@tailcall]) st rollback_pos
    | '"'
    | '\\' ->
      st.yycursor <- st.yycursor + 1;
      (yy246 [@tailcall]) st rollback_pos
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy247 [@tailcall]) st rollback_pos
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy248 [@tailcall]) st rollback_pos
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy249 [@tailcall]) st rollback_pos
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy250 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy229 [@tailcall]) st rollback_pos
        else (yy224 [@tailcall]) st rollback_pos
      ) else (
        (yy224 [@tailcall]) st rollback_pos
      )

and yy230 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy225 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy230 [@tailcall]) st rollback_pos
        else (yy224 [@tailcall]) st rollback_pos
      ) else (
        (yy224 [@tailcall]) st rollback_pos
      )

and yy231 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy251 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy231 [@tailcall]) st rollback_pos
        else (yy224 [@tailcall]) st rollback_pos
      ) else (
        (yy224 [@tailcall]) st rollback_pos
      )

and yy232 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy232 [@tailcall]) st rollback_pos
    | '"' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy234 [@tailcall]) st rollback_pos
    | '\\' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy235 [@tailcall]) st rollback_pos
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy236 [@tailcall]) st rollback_pos
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy237 [@tailcall]) st rollback_pos
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy238 [@tailcall]) st rollback_pos
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy239 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy232 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy233 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  st.yycursor <- st.yymarker;
  match st.yyaccept with
    | 0 -> (yy226 [@tailcall]) st rollback_pos
    | 1 -> (yy224 [@tailcall]) st rollback_pos
    | _ -> (yy242 [@tailcall]) st rollback_pos

and yy234 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy252 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy234 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy235 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '"' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy235 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )
    | _ -> (yy254 [@tailcall]) st rollback_pos yych

and yy236 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy232 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy236 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy237 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy259 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy237 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy238 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy260 [@tailcall]) st rollback_pos
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy261 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy238 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy239 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy259 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy239 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy240 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy262 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy240 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy241 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy241 [@tailcall]) st rollback_pos
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy263 [@tailcall]) st rollback_pos
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy248 [@tailcall]) st rollback_pos
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy264 [@tailcall]) st rollback_pos
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy250 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy241 [@tailcall]) st rollback_pos
        else (yy242 [@tailcall]) st rollback_pos
      ) else (
        (yy242 [@tailcall]) st rollback_pos
      )

and yy242 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  whitespace_escape st; detect_multiline_string_prefix st rollback_pos

and yy243 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  (yy244 [@tailcall]) st rollback_pos

and yy244 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  
    newline st;
    whitespace_escape st;
    detect_multiline_string_prefix st rollback_pos


and yy245 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy243 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy245 [@tailcall]) st rollback_pos
        else (yy244 [@tailcall]) st rollback_pos
      ) else (
        (yy244 [@tailcall]) st rollback_pos
      )

and yy246 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  detect_multiline_string_prefix st rollback_pos

and yy247 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy243 [@tailcall]) st rollback_pos
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy241 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy247 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy248 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy265 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy248 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy249 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy266 [@tailcall]) st rollback_pos
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy267 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy249 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy250 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy265 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy250 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy251 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy225 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy251 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy252 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy268 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy252 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy253 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  (yy254 [@tailcall]) st rollback_pos yych

and yy254 (st : tokenizer_state) (rollback_pos : Lexing.position) (yych : char) : string =
  match yych with
    | '\t'..'\r'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy253 [@tailcall]) st rollback_pos
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy234 [@tailcall]) st rollback_pos
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy255 [@tailcall]) st rollback_pos
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy256 [@tailcall]) st rollback_pos
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy257 [@tailcall]) st rollback_pos
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy258 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy253 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy255 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x85'
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy253 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy255 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy256 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy269 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy256 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy257 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy270 [@tailcall]) st rollback_pos
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy271 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy257 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy258 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy269 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy258 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy259 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy232 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy259 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy260 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy232 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy260 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy261 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy232 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy261 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy262 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  
    rollback_start_to_newline st;
    error st "Invalid multiline string: non-whitespace prefix"


and yy263 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy241 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy263 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy264 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy272 [@tailcall]) st rollback_pos
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy267 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy264 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy265 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy241 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy265 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy266 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy241 [@tailcall]) st rollback_pos
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy243 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy266 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy267 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy241 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy267 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy268 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  st.t1 <- st.yyt1;
  st.t2 <- st.yyt2;
  
    rollback_to_pos st rollback_pos;
    substr st st.t1 st.t2


and yy269 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy253 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy269 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy270 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xA8'..'\xA9'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy253 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy270 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy271 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy253 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy271 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy272 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy241 [@tailcall]) st rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy272 [@tailcall]) st rollback_pos
        else (yy233 [@tailcall]) st rollback_pos
      ) else (
        (yy233 [@tailcall]) st rollback_pos
      )

and yy273 (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  error st "Unterminated multiline string"

and detect_multiline_string_prefix_body (st : tokenizer_state) (rollback_pos : Lexing.position) : string =
  (yy222 [@tailcall]) st rollback_pos



and detect_multiline_string_prefix st rollback_pos =
  save_start_position st;
  detect_multiline_string_prefix_body st rollback_pos


let rec yy274 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy277 [@tailcall]) st exp_hashlen rollback_pos
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy279 [@tailcall]) st exp_hashlen rollback_pos
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy280 [@tailcall]) st exp_hashlen rollback_pos
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy281 [@tailcall]) st exp_hashlen rollback_pos
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy282 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy274 [@tailcall]) st exp_hashlen rollback_pos
        else (yy302 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy275 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy275 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  (yy276 [@tailcall]) st exp_hashlen rollback_pos

and yy276 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  detect_raw_multiline_string_prefix st exp_hashlen rollback_pos

and yy277 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy283 [@tailcall]) st exp_hashlen rollback_pos
    | '"' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy285 [@tailcall]) st exp_hashlen rollback_pos
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy286 [@tailcall]) st exp_hashlen rollback_pos
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy287 [@tailcall]) st exp_hashlen rollback_pos
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy288 [@tailcall]) st exp_hashlen rollback_pos
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy289 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy277 [@tailcall]) st exp_hashlen rollback_pos
        else (yy278 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy278 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy278 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  newline st; detect_raw_multiline_string_prefix st exp_hashlen rollback_pos

and yy279 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy283 [@tailcall]) st exp_hashlen rollback_pos
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy277 [@tailcall]) st exp_hashlen rollback_pos
    | '"' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy285 [@tailcall]) st exp_hashlen rollback_pos
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy286 [@tailcall]) st exp_hashlen rollback_pos
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy287 [@tailcall]) st exp_hashlen rollback_pos
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy288 [@tailcall]) st exp_hashlen rollback_pos
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy289 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy279 [@tailcall]) st exp_hashlen rollback_pos
        else (yy278 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy278 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy280 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy290 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy280 [@tailcall]) st exp_hashlen rollback_pos
        else (yy276 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy276 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy281 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy277 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy281 [@tailcall]) st exp_hashlen rollback_pos
        else (yy276 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy276 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy282 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy291 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy282 [@tailcall]) st exp_hashlen rollback_pos
        else (yy276 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy276 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy283 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy283 [@tailcall]) st exp_hashlen rollback_pos
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy285 [@tailcall]) st exp_hashlen rollback_pos
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy286 [@tailcall]) st exp_hashlen rollback_pos
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy287 [@tailcall]) st exp_hashlen rollback_pos
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy288 [@tailcall]) st exp_hashlen rollback_pos
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy289 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy283 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy284 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  st.yycursor <- st.yymarker;
  if (st.yyaccept == 0) then (yy278 [@tailcall]) st exp_hashlen rollback_pos
  else (yy276 [@tailcall]) st exp_hashlen rollback_pos

and yy285 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy292 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy285 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy286 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy283 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy286 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy287 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy293 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy287 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy288 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy294 [@tailcall]) st exp_hashlen rollback_pos
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy295 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy288 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy289 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy293 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy289 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy290 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy296 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy290 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy291 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy277 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy291 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy292 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy297 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy292 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy293 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy283 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy293 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy294 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy283 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy294 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy295 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy283 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy295 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy296 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '#' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy298 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy296 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy297 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '#' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy300 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy297 [@tailcall]) st exp_hashlen rollback_pos
        else (yy284 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy284 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy298 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '#' ->
      st.yycursor <- st.yycursor + 1;
      (yy298 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy298 [@tailcall]) st exp_hashlen rollback_pos
        else (yy299 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy299 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy299 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  st.t1 <- st.yyt1;
  
    if st.yycursor - st.t1 >= exp_hashlen then begin
      rollback_start_to_newline st;
      error st "Invalid multiline string: non-whitespace prefix"
    end else detect_raw_multiline_string_prefix st exp_hashlen rollback_pos


and yy300 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '#' ->
      st.yycursor <- st.yycursor + 1;
      (yy300 [@tailcall]) st exp_hashlen rollback_pos
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy300 [@tailcall]) st exp_hashlen rollback_pos
        else (yy301 [@tailcall]) st exp_hashlen rollback_pos
      ) else (
        (yy301 [@tailcall]) st exp_hashlen rollback_pos
      )

and yy301 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  st.t1 <- st.yyt1;
  st.t3 <- st.yyt2;
  st.t2 <- st.yyt2;
  st.t2 <- st.t2 - 3;
  
    if st.yycursor - st.t3 >= exp_hashlen then begin
      rollback_to_pos st rollback_pos;
      substr st st.t1 st.t2
    end else detect_raw_multiline_string_prefix st exp_hashlen rollback_pos


and yy302 (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  error st "Unterminated raw multiline string"

and detect_raw_multiline_string_prefix_body (st : tokenizer_state) (exp_hashlen : int) (rollback_pos : Lexing.position) : string =
  (yy274 [@tailcall]) st exp_hashlen rollback_pos



and detect_raw_multiline_string_prefix st exp_hashlen rollback_pos =
  save_start_position st;
  detect_raw_multiline_string_prefix_body st exp_hashlen rollback_pos

let multiline_prefix_check st prefix =
  let { t1; t2; yyinput; _ } = st in
  newline ~pos:t1 st;
  let ws_len = t2 - t1 in
  for i = t1 to t1 + String.length prefix - 1 do
    let ch = Bytes.unsafe_get yyinput i in
    let prefix_i = i - t1 in
    if i >= t2 || ch != String.unsafe_get prefix prefix_i then
      error st "Invalid multiline string: unmatched whitespace prefix"
  done;
  Buffer.add_char st.info.strbuf '\n';
  let rest_len = ws_len - String.length prefix in
  let rest_start = t1 + String.length prefix in
  if rest_len > 0 then
    Buffer.add_subbytes st.info.strbuf yyinput rest_start rest_len

let multiline_contents strbuf =
  let len = Buffer.length strbuf in
  (* Strip the first and the last \n *)
  if len <= 1 then "" else Buffer.sub strbuf 1 (len - 2)


let rec yy304 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy304 [@tailcall]) st prefix
        else (yy393 [@tailcall]) st prefix
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy305 [@tailcall]) st prefix
      )
    | '\t'
    | ' '..'!'
    | '#'..'['
    | ']'..'~' ->
      st.yycursor <- st.yycursor + 1;
      (yy306 [@tailcall]) st prefix
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy308 [@tailcall]) st prefix
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy310 [@tailcall]) st prefix
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy311 [@tailcall]) st prefix
    | '\\' ->
      st.yycursor <- st.yycursor + 1;
      (yy312 [@tailcall]) st prefix
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy315 [@tailcall]) st prefix
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy316 [@tailcall]) st prefix
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy317 [@tailcall]) st prefix
    | '\xE1'
    | '\xE3'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy318 [@tailcall]) st prefix
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy319 [@tailcall]) st prefix
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy320 [@tailcall]) st prefix
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy321 [@tailcall]) st prefix
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy322 [@tailcall]) st prefix
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy323 [@tailcall]) st prefix
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy324 [@tailcall]) st prefix
    | _ ->
      st.yycursor <- st.yycursor + 1;
      (yy313 [@tailcall]) st prefix

and yy305 (st : tokenizer_state) (prefix : string) : token =
  error st "Illegal character"

and yy306 (st : tokenizer_state) (prefix : string) : token =
  (yy307 [@tailcall]) st prefix

and yy307 (st : tokenizer_state) (prefix : string) : token =
  add_lexeme_to_buf st st.info.strbuf; yyfnmulti' st prefix

and yy308 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy308 [@tailcall]) st prefix
        else (yy309 [@tailcall]) st prefix
      ) else (
        st.yyt1 <- st.yycursor;
        st.yyt2 <- st.yycursor;
        st.yycursor <- st.yycursor + 1;
        (yy325 [@tailcall]) st prefix
      )
    | '\t'
    | ' ' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy326 [@tailcall]) st prefix
    | '\n'..'\x0C' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy328 [@tailcall]) st prefix
    | '\r' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy330 [@tailcall]) st prefix
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy331 [@tailcall]) st prefix
    | '\xC3'..'\xDF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy332 [@tailcall]) st prefix
    | '\xE0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy333 [@tailcall]) st prefix
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy334 [@tailcall]) st prefix
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy335 [@tailcall]) st prefix
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy336 [@tailcall]) st prefix
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy337 [@tailcall]) st prefix
    | '\xED' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy338 [@tailcall]) st prefix
    | '\xF0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy339 [@tailcall]) st prefix
    | '\xF1'..'\xF3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy340 [@tailcall]) st prefix
    | '\xF4' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy341 [@tailcall]) st prefix
    | _ -> (yy309 [@tailcall]) st prefix

and yy309 (st : tokenizer_state) (prefix : string) : token =
  newline st; yyfnmulti' st prefix

and yy310 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy310 [@tailcall]) st prefix
        else (yy309 [@tailcall]) st prefix
      ) else (
        st.yyt1 <- st.yycursor;
        st.yyt2 <- st.yycursor;
        st.yycursor <- st.yycursor + 1;
        (yy325 [@tailcall]) st prefix
      )
    | '\t'
    | ' ' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy326 [@tailcall]) st prefix
    | '\n' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy342 [@tailcall]) st prefix
    | '\x0B'..'\x0C' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy328 [@tailcall]) st prefix
    | '\r' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy330 [@tailcall]) st prefix
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy331 [@tailcall]) st prefix
    | '\xC3'..'\xDF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy332 [@tailcall]) st prefix
    | '\xE0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy333 [@tailcall]) st prefix
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy334 [@tailcall]) st prefix
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy335 [@tailcall]) st prefix
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy336 [@tailcall]) st prefix
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy337 [@tailcall]) st prefix
    | '\xED' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy338 [@tailcall]) st prefix
    | '\xF0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy339 [@tailcall]) st prefix
    | '\xF1'..'\xF3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy340 [@tailcall]) st prefix
    | '\xF4' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy341 [@tailcall]) st prefix
    | _ -> (yy309 [@tailcall]) st prefix

and yy311 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy343 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy311 [@tailcall]) st prefix
        else (yy307 [@tailcall]) st prefix
      ) else (
        (yy307 [@tailcall]) st prefix
      )

and yy312 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'
    | '#'..'['
    | ']'..'a'
    | 'c'..'e'
    | 'g'..'m'
    | 'o'..'q'
    | 'v'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy312 [@tailcall]) st prefix
        else (yy307 [@tailcall]) st prefix
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy344 [@tailcall]) st prefix
      )
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy346 [@tailcall]) st prefix
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy348 [@tailcall]) st prefix
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy350 [@tailcall]) st prefix
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy351 [@tailcall]) st prefix
    | '\\' ->
      st.yycursor <- st.yycursor + 1;
      (yy352 [@tailcall]) st prefix
    | 'b' ->
      st.yycursor <- st.yycursor + 1;
      (yy353 [@tailcall]) st prefix
    | 'f' ->
      st.yycursor <- st.yycursor + 1;
      (yy354 [@tailcall]) st prefix
    | 'n' ->
      st.yycursor <- st.yycursor + 1;
      (yy355 [@tailcall]) st prefix
    | 'r' ->
      st.yycursor <- st.yycursor + 1;
      (yy356 [@tailcall]) st prefix
    | 's' ->
      st.yycursor <- st.yycursor + 1;
      (yy357 [@tailcall]) st prefix
    | 't' ->
      st.yycursor <- st.yycursor + 1;
      (yy358 [@tailcall]) st prefix
    | 'u' ->
      st.yycursor <- st.yycursor + 1;
      (yy359 [@tailcall]) st prefix
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy360 [@tailcall]) st prefix
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy361 [@tailcall]) st prefix
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy362 [@tailcall]) st prefix
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy363 [@tailcall]) st prefix
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy364 [@tailcall]) st prefix
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy365 [@tailcall]) st prefix
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy366 [@tailcall]) st prefix
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy367 [@tailcall]) st prefix
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy368 [@tailcall]) st prefix
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy369 [@tailcall]) st prefix
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy370 [@tailcall]) st prefix
    | _ -> (yy307 [@tailcall]) st prefix

and yy313 (st : tokenizer_state) (prefix : string) : token =
  (yy314 [@tailcall]) st prefix

and yy314 (st : tokenizer_state) (prefix : string) : token =
  malformed_utf8 st

and yy315 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy306 [@tailcall]) st prefix
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy308 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy315 [@tailcall]) st prefix
        else (yy314 [@tailcall]) st prefix
      ) else (
        (yy314 [@tailcall]) st prefix
      )

and yy316 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy306 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy316 [@tailcall]) st prefix
        else (yy314 [@tailcall]) st prefix
      ) else (
        (yy314 [@tailcall]) st prefix
      )

and yy317 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy371 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy317 [@tailcall]) st prefix
        else (yy314 [@tailcall]) st prefix
      ) else (
        (yy314 [@tailcall]) st prefix
      )

and yy318 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy371 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy318 [@tailcall]) st prefix
        else (yy314 [@tailcall]) st prefix
      ) else (
        (yy314 [@tailcall]) st prefix
      )

and yy319 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy372 [@tailcall]) st prefix
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy373 [@tailcall]) st prefix
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy371 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy319 [@tailcall]) st prefix
        else (yy314 [@tailcall]) st prefix
      ) else (
        (yy314 [@tailcall]) st prefix
      )

and yy320 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy371 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy320 [@tailcall]) st prefix
        else (yy314 [@tailcall]) st prefix
      ) else (
        (yy314 [@tailcall]) st prefix
      )

and yy321 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy371 [@tailcall]) st prefix
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy374 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy321 [@tailcall]) st prefix
        else (yy314 [@tailcall]) st prefix
      ) else (
        (yy314 [@tailcall]) st prefix
      )

and yy322 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy375 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy322 [@tailcall]) st prefix
        else (yy314 [@tailcall]) st prefix
      ) else (
        (yy314 [@tailcall]) st prefix
      )

and yy323 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy375 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy323 [@tailcall]) st prefix
        else (yy314 [@tailcall]) st prefix
      ) else (
        (yy314 [@tailcall]) st prefix
      )

and yy324 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy375 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy324 [@tailcall]) st prefix
        else (yy314 [@tailcall]) st prefix
      ) else (
        (yy314 [@tailcall]) st prefix
      )

and yy325 (st : tokenizer_state) (prefix : string) : token =
  st.t1 <- st.yyt1;
  st.t2 <- st.yyt2;
  st.yycursor <- st.yyt2;
  
    multiline_prefix_check st prefix;
    yyfnmulti' st prefix


and yy326 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy326 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        st.yyt2 <- st.yycursor;
        st.yycursor <- st.yycursor + 1;
        (yy325 [@tailcall]) st prefix
      )
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy326 [@tailcall]) st prefix
    | '\n'..'\x0C' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy328 [@tailcall]) st prefix
    | '\r' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy330 [@tailcall]) st prefix
    | '\xC2' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy331 [@tailcall]) st prefix
    | '\xC3'..'\xDF' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy332 [@tailcall]) st prefix
    | '\xE0' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy333 [@tailcall]) st prefix
    | '\xE1' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy334 [@tailcall]) st prefix
    | '\xE2' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy335 [@tailcall]) st prefix
    | '\xE3' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy336 [@tailcall]) st prefix
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy337 [@tailcall]) st prefix
    | '\xED' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy338 [@tailcall]) st prefix
    | '\xF0' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy339 [@tailcall]) st prefix
    | '\xF1'..'\xF3' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy340 [@tailcall]) st prefix
    | '\xF4' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy341 [@tailcall]) st prefix
    | _ -> (yy327 [@tailcall]) st prefix

and yy327 (st : tokenizer_state) (prefix : string) : token =
  st.yycursor <- st.yymarker;
  match st.yyaccept with
    | 0 -> (yy309 [@tailcall]) st prefix
    | 1 -> (yy307 [@tailcall]) st prefix
    | 2 -> (yy314 [@tailcall]) st prefix
    | 3 -> (yy329 [@tailcall]) st prefix
    | 4 -> (yy347 [@tailcall]) st prefix
    | _ -> (yy345 [@tailcall]) st prefix

and yy328 (st : tokenizer_state) (prefix : string) : token =
  (yy329 [@tailcall]) st prefix

and yy329 (st : tokenizer_state) (prefix : string) : token =
  st.t1 <- st.yyt1;
  st.yycursor <- st.yyt2;
  
    newline ~pos:st.t1 st;
    (* Any newline is normalized to \n *)
    Buffer.add_char st.info.strbuf '\n';
    (* Skip lines consisting of any whitespace only (do not check the prefix) *)
    yyfnmulti' st prefix


and yy330 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy328 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy330 [@tailcall]) st prefix
        else (yy329 [@tailcall]) st prefix
      ) else (
        (yy329 [@tailcall]) st prefix
      )

and yy331 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy325 [@tailcall]) st prefix
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy328 [@tailcall]) st prefix
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy326 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy331 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy332 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy325 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy332 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy333 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy332 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy333 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy334 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy332 [@tailcall]) st prefix
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy376 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy334 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy335 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy377 [@tailcall]) st prefix
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy378 [@tailcall]) st prefix
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy332 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy335 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy336 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy376 [@tailcall]) st prefix
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy332 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy336 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy337 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy332 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy337 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy338 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy332 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy338 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy339 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy337 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy339 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy340 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy337 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy340 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy341 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy337 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy341 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy342 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 3;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy342 [@tailcall]) st prefix
        else (yy329 [@tailcall]) st prefix
      ) else (
        st.yyt1 <- st.yycursor;
        st.yyt2 <- st.yycursor;
        st.yycursor <- st.yycursor + 1;
        (yy325 [@tailcall]) st prefix
      )
    | '\t'
    | ' ' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy326 [@tailcall]) st prefix
    | '\n'..'\x0C' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy328 [@tailcall]) st prefix
    | '\r' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy330 [@tailcall]) st prefix
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy331 [@tailcall]) st prefix
    | '\xC3'..'\xDF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy332 [@tailcall]) st prefix
    | '\xE0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy333 [@tailcall]) st prefix
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy334 [@tailcall]) st prefix
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy335 [@tailcall]) st prefix
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy336 [@tailcall]) st prefix
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy337 [@tailcall]) st prefix
    | '\xED' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy338 [@tailcall]) st prefix
    | '\xF0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy339 [@tailcall]) st prefix
    | '\xF1'..'\xF3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy340 [@tailcall]) st prefix
    | '\xF4' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy341 [@tailcall]) st prefix
    | _ -> (yy329 [@tailcall]) st prefix

and yy343 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy379 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy343 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy344 (st : tokenizer_state) (prefix : string) : token =
  (yy345 [@tailcall]) st prefix

and yy345 (st : tokenizer_state) (prefix : string) : token =
  error st "Invalid escape sequence"

and yy346 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 4;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy346 [@tailcall]) st prefix
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy380 [@tailcall]) st prefix
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy381 [@tailcall]) st prefix
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy382 [@tailcall]) st prefix
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy383 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy346 [@tailcall]) st prefix
        else (yy347 [@tailcall]) st prefix
      ) else (
        (yy347 [@tailcall]) st prefix
      )

and yy347 (st : tokenizer_state) (prefix : string) : token =
  whitespace_escape st; string st prefix

and yy348 (st : tokenizer_state) (prefix : string) : token =
  (yy349 [@tailcall]) st prefix

and yy349 (st : tokenizer_state) (prefix : string) : token =
  
    newline st;
    whitespace_escape st;
    string st prefix


and yy350 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy348 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy350 [@tailcall]) st prefix
        else (yy349 [@tailcall]) st prefix
      ) else (
        (yy349 [@tailcall]) st prefix
      )

and yy351 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '"'; string st prefix

and yy352 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\\'; string st prefix

and yy353 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\b'; string st prefix

and yy354 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\012'; string st prefix

and yy355 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\n'; string st prefix

and yy356 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\r'; string st prefix

and yy357 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf ' '; string st prefix

and yy358 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\t'; string st prefix

and yy359 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '{' ->
      st.yycursor <- st.yycursor + 1;
      (yy384 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy359 [@tailcall]) st prefix
        else (yy345 [@tailcall]) st prefix
      ) else (
        (yy345 [@tailcall]) st prefix
      )

and yy360 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy344 [@tailcall]) st prefix
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy348 [@tailcall]) st prefix
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy346 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy360 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy361 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy344 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy361 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy362 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy361 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy362 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy363 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy361 [@tailcall]) st prefix
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy385 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy363 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy364 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy386 [@tailcall]) st prefix
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy387 [@tailcall]) st prefix
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy361 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy364 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy365 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy385 [@tailcall]) st prefix
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy361 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy365 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy366 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy361 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy366 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy367 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy361 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy367 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy368 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy366 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy368 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy369 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy366 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy369 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy370 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy366 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy370 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy371 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy306 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy371 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy372 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8D'
    | '\x90'..'\xA7'
    | '\xAF'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy306 [@tailcall]) st prefix
    | '\x8E'..'\x8F'
    | '\xAA'..'\xAE' ->
      st.yycursor <- st.yycursor + 1;
      (yy305 [@tailcall]) st prefix
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy308 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy372 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy373 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy306 [@tailcall]) st prefix
    | '\xA6'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy305 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy373 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy374 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy306 [@tailcall]) st prefix
    | '\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy305 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy374 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy375 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy371 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy375 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy376 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy326 [@tailcall]) st prefix
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy325 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy376 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy377 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy326 [@tailcall]) st prefix
    | '\x8B'..'\xA7'
    | '\xAA'..'\xAE'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy325 [@tailcall]) st prefix
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy328 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy377 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy378 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy325 [@tailcall]) st prefix
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy326 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy378 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy379 (st : tokenizer_state) (prefix : string) : token =
  QUOTED_STRING (multiline_contents st.info.strbuf)

and yy380 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy346 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy380 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy381 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy388 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy381 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy382 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy389 [@tailcall]) st prefix
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy390 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy382 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy383 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy388 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy383 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy384 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '0'..'9'
    | 'A'..'F'
    | 'a'..'f' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy391 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy384 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy385 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy346 [@tailcall]) st prefix
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy344 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy385 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy386 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy346 [@tailcall]) st prefix
    | '\x8B'..'\xA7'
    | '\xAA'..'\xAE'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy344 [@tailcall]) st prefix
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy348 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy386 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy387 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy344 [@tailcall]) st prefix
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy346 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy387 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy388 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy346 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy388 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy389 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy346 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy389 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy390 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy346 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy390 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy391 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '0'..'9'
    | 'A'..'F'
    | 'a'..'f' ->
      st.yycursor <- st.yycursor + 1;
      (yy391 [@tailcall]) st prefix
    | '}' ->
      st.yycursor <- st.yycursor + 1;
      (yy392 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy391 [@tailcall]) st prefix
        else (yy327 [@tailcall]) st prefix
      ) else (
        (yy327 [@tailcall]) st prefix
      )

and yy392 (st : tokenizer_state) (prefix : string) : token =
  st.t1 <- st.yyt1;
  st.t2 <- st.yycursor;
  st.t2 <- st.t2 - 1;
  
    let len = st.t2 - st.t1 in
    if len > 6 then
      error st "Invalid unicode scalar value (too many digits)";
    let code_str = substr st st.t1 st.t2 in
    let code = Scanf.sscanf code_str "%X%!" (fun x -> x) in
    if not @@ Uchar.is_valid code then
      error st "Invalid unicode scalar value";
    Buffer.add_utf_8_uchar st.info.strbuf (Uchar.unsafe_of_int code);
    string st prefix


and yy393 (st : tokenizer_state) (prefix : string) : token =
  error st "Unterminated string"

and yyfnmulti (st : tokenizer_state) (prefix : string) : token =
  (yy304 [@tailcall]) st prefix

and yy394 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy394 [@tailcall]) st prefix
        else (yy461 [@tailcall]) st prefix
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy395 [@tailcall]) st prefix
      )
    | '\t'
    | ' '..'!'
    | '#'..'['
    | ']'..'~' ->
      st.yycursor <- st.yycursor + 1;
      (yy396 [@tailcall]) st prefix
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy398 [@tailcall]) st prefix
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy400 [@tailcall]) st prefix
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy401 [@tailcall]) st prefix
    | '\\' ->
      st.yycursor <- st.yycursor + 1;
      (yy402 [@tailcall]) st prefix
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy405 [@tailcall]) st prefix
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy406 [@tailcall]) st prefix
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy407 [@tailcall]) st prefix
    | '\xE1'
    | '\xE3'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy408 [@tailcall]) st prefix
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy409 [@tailcall]) st prefix
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy410 [@tailcall]) st prefix
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy411 [@tailcall]) st prefix
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy412 [@tailcall]) st prefix
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy413 [@tailcall]) st prefix
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy414 [@tailcall]) st prefix
    | _ ->
      st.yycursor <- st.yycursor + 1;
      (yy403 [@tailcall]) st prefix

and yy395 (st : tokenizer_state) (prefix : string) : token =
  error st "Illegal character"

and yy396 (st : tokenizer_state) (prefix : string) : token =
  (yy397 [@tailcall]) st prefix

and yy397 (st : tokenizer_state) (prefix : string) : token =
  add_lexeme_to_buf st st.info.strbuf; yyfnsingle' st prefix

and yy398 (st : tokenizer_state) (prefix : string) : token =
  (yy399 [@tailcall]) st prefix

and yy399 (st : tokenizer_state) (prefix : string) : token =
  newline st; error st "Unterminated string"

and yy400 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy398 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy400 [@tailcall]) st prefix
        else (yy399 [@tailcall]) st prefix
      ) else (
        (yy399 [@tailcall]) st prefix
      )

and yy401 (st : tokenizer_state) (prefix : string) : token =
  QUOTED_STRING (Buffer.contents st.info.strbuf)

and yy402 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'
    | '#'..'['
    | ']'..'a'
    | 'c'..'e'
    | 'g'..'m'
    | 'o'..'q'
    | 'v'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy402 [@tailcall]) st prefix
        else (yy397 [@tailcall]) st prefix
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy415 [@tailcall]) st prefix
      )
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy417 [@tailcall]) st prefix
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy419 [@tailcall]) st prefix
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy421 [@tailcall]) st prefix
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy422 [@tailcall]) st prefix
    | '\\' ->
      st.yycursor <- st.yycursor + 1;
      (yy423 [@tailcall]) st prefix
    | 'b' ->
      st.yycursor <- st.yycursor + 1;
      (yy424 [@tailcall]) st prefix
    | 'f' ->
      st.yycursor <- st.yycursor + 1;
      (yy425 [@tailcall]) st prefix
    | 'n' ->
      st.yycursor <- st.yycursor + 1;
      (yy426 [@tailcall]) st prefix
    | 'r' ->
      st.yycursor <- st.yycursor + 1;
      (yy427 [@tailcall]) st prefix
    | 's' ->
      st.yycursor <- st.yycursor + 1;
      (yy428 [@tailcall]) st prefix
    | 't' ->
      st.yycursor <- st.yycursor + 1;
      (yy429 [@tailcall]) st prefix
    | 'u' ->
      st.yycursor <- st.yycursor + 1;
      (yy430 [@tailcall]) st prefix
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy431 [@tailcall]) st prefix
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy433 [@tailcall]) st prefix
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy434 [@tailcall]) st prefix
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy435 [@tailcall]) st prefix
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy436 [@tailcall]) st prefix
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy437 [@tailcall]) st prefix
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy438 [@tailcall]) st prefix
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy439 [@tailcall]) st prefix
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy440 [@tailcall]) st prefix
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy441 [@tailcall]) st prefix
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy442 [@tailcall]) st prefix
    | _ -> (yy397 [@tailcall]) st prefix

and yy403 (st : tokenizer_state) (prefix : string) : token =
  (yy404 [@tailcall]) st prefix

and yy404 (st : tokenizer_state) (prefix : string) : token =
  malformed_utf8 st

and yy405 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy396 [@tailcall]) st prefix
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy398 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy405 [@tailcall]) st prefix
        else (yy404 [@tailcall]) st prefix
      ) else (
        (yy404 [@tailcall]) st prefix
      )

and yy406 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy396 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy406 [@tailcall]) st prefix
        else (yy404 [@tailcall]) st prefix
      ) else (
        (yy404 [@tailcall]) st prefix
      )

and yy407 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy443 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy407 [@tailcall]) st prefix
        else (yy404 [@tailcall]) st prefix
      ) else (
        (yy404 [@tailcall]) st prefix
      )

and yy408 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy443 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy408 [@tailcall]) st prefix
        else (yy404 [@tailcall]) st prefix
      ) else (
        (yy404 [@tailcall]) st prefix
      )

and yy409 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy444 [@tailcall]) st prefix
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy445 [@tailcall]) st prefix
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy443 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy409 [@tailcall]) st prefix
        else (yy404 [@tailcall]) st prefix
      ) else (
        (yy404 [@tailcall]) st prefix
      )

and yy410 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy443 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy410 [@tailcall]) st prefix
        else (yy404 [@tailcall]) st prefix
      ) else (
        (yy404 [@tailcall]) st prefix
      )

and yy411 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy443 [@tailcall]) st prefix
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy446 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy411 [@tailcall]) st prefix
        else (yy404 [@tailcall]) st prefix
      ) else (
        (yy404 [@tailcall]) st prefix
      )

and yy412 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy447 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy412 [@tailcall]) st prefix
        else (yy404 [@tailcall]) st prefix
      ) else (
        (yy404 [@tailcall]) st prefix
      )

and yy413 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy447 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy413 [@tailcall]) st prefix
        else (yy404 [@tailcall]) st prefix
      ) else (
        (yy404 [@tailcall]) st prefix
      )

and yy414 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy447 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy414 [@tailcall]) st prefix
        else (yy404 [@tailcall]) st prefix
      ) else (
        (yy404 [@tailcall]) st prefix
      )

and yy415 (st : tokenizer_state) (prefix : string) : token =
  (yy416 [@tailcall]) st prefix

and yy416 (st : tokenizer_state) (prefix : string) : token =
  error st "Invalid escape sequence"

and yy417 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy417 [@tailcall]) st prefix
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy448 [@tailcall]) st prefix
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy449 [@tailcall]) st prefix
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy450 [@tailcall]) st prefix
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy451 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy417 [@tailcall]) st prefix
        else (yy418 [@tailcall]) st prefix
      ) else (
        (yy418 [@tailcall]) st prefix
      )

and yy418 (st : tokenizer_state) (prefix : string) : token =
  whitespace_escape st; string st prefix

and yy419 (st : tokenizer_state) (prefix : string) : token =
  (yy420 [@tailcall]) st prefix

and yy420 (st : tokenizer_state) (prefix : string) : token =
  
    newline st;
    whitespace_escape st;
    string st prefix


and yy421 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy419 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy421 [@tailcall]) st prefix
        else (yy420 [@tailcall]) st prefix
      ) else (
        (yy420 [@tailcall]) st prefix
      )

and yy422 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '"'; string st prefix

and yy423 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\\'; string st prefix

and yy424 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\b'; string st prefix

and yy425 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\012'; string st prefix

and yy426 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\n'; string st prefix

and yy427 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\r'; string st prefix

and yy428 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf ' '; string st prefix

and yy429 (st : tokenizer_state) (prefix : string) : token =
  Buffer.add_char st.info.strbuf '\t'; string st prefix

and yy430 (st : tokenizer_state) (prefix : string) : token =
  st.yyaccept <- 3;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '{' ->
      st.yycursor <- st.yycursor + 1;
      (yy452 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy430 [@tailcall]) st prefix
        else (yy416 [@tailcall]) st prefix
      ) else (
        (yy416 [@tailcall]) st prefix
      )

and yy431 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy415 [@tailcall]) st prefix
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy419 [@tailcall]) st prefix
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy417 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy431 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy432 (st : tokenizer_state) (prefix : string) : token =
  st.yycursor <- st.yymarker;
  match st.yyaccept with
    | 0 -> (yy397 [@tailcall]) st prefix
    | 1 -> (yy404 [@tailcall]) st prefix
    | 2 -> (yy418 [@tailcall]) st prefix
    | _ -> (yy416 [@tailcall]) st prefix

and yy433 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy415 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy433 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy434 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy433 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy434 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy435 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy433 [@tailcall]) st prefix
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy453 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy435 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy436 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy454 [@tailcall]) st prefix
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy455 [@tailcall]) st prefix
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy433 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy436 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy437 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy453 [@tailcall]) st prefix
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy433 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy437 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy438 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy433 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy438 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy439 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy433 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy439 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy440 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy438 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy440 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy441 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy438 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy441 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy442 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy438 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy442 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy443 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy396 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy443 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy444 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8D'
    | '\x90'..'\xA7'
    | '\xAF'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy396 [@tailcall]) st prefix
    | '\x8E'..'\x8F'
    | '\xAA'..'\xAE' ->
      st.yycursor <- st.yycursor + 1;
      (yy395 [@tailcall]) st prefix
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy398 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy444 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy445 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy396 [@tailcall]) st prefix
    | '\xA6'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy395 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy445 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy446 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy396 [@tailcall]) st prefix
    | '\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy395 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy446 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy447 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy443 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy447 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy448 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy417 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy448 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy449 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy456 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy449 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy450 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy457 [@tailcall]) st prefix
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy458 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy450 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy451 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy456 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy451 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy452 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '0'..'9'
    | 'A'..'F'
    | 'a'..'f' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy459 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy452 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy453 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy417 [@tailcall]) st prefix
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy415 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy453 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy454 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy417 [@tailcall]) st prefix
    | '\x8B'..'\xA7'
    | '\xAA'..'\xAE'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy415 [@tailcall]) st prefix
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy419 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy454 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy455 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy415 [@tailcall]) st prefix
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy417 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy455 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy456 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy417 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy456 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy457 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy417 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy457 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy458 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy417 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy458 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy459 (st : tokenizer_state) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '0'..'9'
    | 'A'..'F'
    | 'a'..'f' ->
      st.yycursor <- st.yycursor + 1;
      (yy459 [@tailcall]) st prefix
    | '}' ->
      st.yycursor <- st.yycursor + 1;
      (yy460 [@tailcall]) st prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy459 [@tailcall]) st prefix
        else (yy432 [@tailcall]) st prefix
      ) else (
        (yy432 [@tailcall]) st prefix
      )

and yy460 (st : tokenizer_state) (prefix : string) : token =
  st.t1 <- st.yyt1;
  st.t2 <- st.yycursor;
  st.t2 <- st.t2 - 1;
  
    let len = st.t2 - st.t1 in
    if len > 6 then
      error st "Invalid unicode scalar value (too many digits)";
    let code_str = substr st st.t1 st.t2 in
    let code = Scanf.sscanf code_str "%X%!" (fun x -> x) in
    if not @@ Uchar.is_valid code then
      error st "Invalid unicode scalar value";
    Buffer.add_utf_8_uchar st.info.strbuf (Uchar.unsafe_of_int code);
    string st prefix


and yy461 (st : tokenizer_state) (prefix : string) : token =
  error st "Unterminated string"

and yyfnsingle (st : tokenizer_state) (prefix : string) : token =
  (yy394 [@tailcall]) st prefix

and yy303 (st : tokenizer_state) (prefix : string) : token =
  match st.yycond with
    | YYC_multi -> (yyfnmulti [@tailcall]) st prefix
    | YYC_single -> (yyfnsingle [@tailcall]) st prefix

and string_body (st : tokenizer_state) (prefix : string) : token =
  (yy303 [@tailcall]) st prefix



and yyfnsingle' st prefix = save_start_position st; yyfnsingle st prefix
and yyfnmulti' st prefix = save_start_position st; yyfnmulti st prefix
and string st prefix = save_start_position st; string_body st prefix

let string_multiline st =
  validate_multiline_start st;
  let prefix = detect_multiline_string_prefix st (make_lexing_end_pos st) in
  st.yycond <- YYC_multi;
  string st prefix

let string_singleline st = st.yycond <- YYC_single; string st ""

let check_hashlen st exp_hashlen =
  let got_hashlen = st.yycursor - st.t1 in
  if got_hashlen > exp_hashlen then
    error st (sprintf "Expected %d hash symbol(s), got %d" exp_hashlen got_hashlen)
  else if got_hashlen < exp_hashlen then begin
    add_lexeme_to_buf st st.info.strbuf;
    false
  end else
    true


let rec yy463 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy463 [@tailcall]) st exp_hashlen prefix
        else (yy513 [@tailcall]) st exp_hashlen prefix
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy464 [@tailcall]) st exp_hashlen prefix
      )
    | '\t'
    | ' '..'!'
    | '#'..'~' ->
      st.yycursor <- st.yycursor + 1;
      (yy465 [@tailcall]) st exp_hashlen prefix
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy467 [@tailcall]) st exp_hashlen prefix
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy469 [@tailcall]) st exp_hashlen prefix
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy470 [@tailcall]) st exp_hashlen prefix
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy473 [@tailcall]) st exp_hashlen prefix
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy474 [@tailcall]) st exp_hashlen prefix
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy475 [@tailcall]) st exp_hashlen prefix
    | '\xE1'
    | '\xE3'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy476 [@tailcall]) st exp_hashlen prefix
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy477 [@tailcall]) st exp_hashlen prefix
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy478 [@tailcall]) st exp_hashlen prefix
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy479 [@tailcall]) st exp_hashlen prefix
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy480 [@tailcall]) st exp_hashlen prefix
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy481 [@tailcall]) st exp_hashlen prefix
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy482 [@tailcall]) st exp_hashlen prefix
    | _ ->
      st.yycursor <- st.yycursor + 1;
      (yy471 [@tailcall]) st exp_hashlen prefix

and yy464 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  error st "Illegal character"

and yy465 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  (yy466 [@tailcall]) st exp_hashlen prefix

and yy466 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  add_lexeme_to_buf st st.info.strbuf; yyfnrmulti' st exp_hashlen prefix

and yy467 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy467 [@tailcall]) st exp_hashlen prefix
        else (yy468 [@tailcall]) st exp_hashlen prefix
      ) else (
        st.yyt1 <- st.yycursor;
        st.yyt2 <- st.yycursor;
        st.yycursor <- st.yycursor + 1;
        (yy483 [@tailcall]) st exp_hashlen prefix
      )
    | '\t'
    | ' ' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy484 [@tailcall]) st exp_hashlen prefix
    | '\n'..'\x0C' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy486 [@tailcall]) st exp_hashlen prefix
    | '\r' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy488 [@tailcall]) st exp_hashlen prefix
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy489 [@tailcall]) st exp_hashlen prefix
    | '\xC3'..'\xDF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy490 [@tailcall]) st exp_hashlen prefix
    | '\xE0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy491 [@tailcall]) st exp_hashlen prefix
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy492 [@tailcall]) st exp_hashlen prefix
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy493 [@tailcall]) st exp_hashlen prefix
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy494 [@tailcall]) st exp_hashlen prefix
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy495 [@tailcall]) st exp_hashlen prefix
    | '\xED' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy496 [@tailcall]) st exp_hashlen prefix
    | '\xF0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy497 [@tailcall]) st exp_hashlen prefix
    | '\xF1'..'\xF3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy498 [@tailcall]) st exp_hashlen prefix
    | '\xF4' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy499 [@tailcall]) st exp_hashlen prefix
    | _ -> (yy468 [@tailcall]) st exp_hashlen prefix

and yy468 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  newline st; yyfnrmulti' st exp_hashlen prefix

and yy469 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy469 [@tailcall]) st exp_hashlen prefix
        else (yy468 [@tailcall]) st exp_hashlen prefix
      ) else (
        st.yyt1 <- st.yycursor;
        st.yyt2 <- st.yycursor;
        st.yycursor <- st.yycursor + 1;
        (yy483 [@tailcall]) st exp_hashlen prefix
      )
    | '\t'
    | ' ' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy484 [@tailcall]) st exp_hashlen prefix
    | '\n' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy500 [@tailcall]) st exp_hashlen prefix
    | '\x0B'..'\x0C' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy486 [@tailcall]) st exp_hashlen prefix
    | '\r' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy488 [@tailcall]) st exp_hashlen prefix
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy489 [@tailcall]) st exp_hashlen prefix
    | '\xC3'..'\xDF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy490 [@tailcall]) st exp_hashlen prefix
    | '\xE0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy491 [@tailcall]) st exp_hashlen prefix
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy492 [@tailcall]) st exp_hashlen prefix
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy493 [@tailcall]) st exp_hashlen prefix
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy494 [@tailcall]) st exp_hashlen prefix
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy495 [@tailcall]) st exp_hashlen prefix
    | '\xED' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy496 [@tailcall]) st exp_hashlen prefix
    | '\xF0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy497 [@tailcall]) st exp_hashlen prefix
    | '\xF1'..'\xF3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy498 [@tailcall]) st exp_hashlen prefix
    | '\xF4' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy499 [@tailcall]) st exp_hashlen prefix
    | _ -> (yy468 [@tailcall]) st exp_hashlen prefix

and yy470 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy501 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy470 [@tailcall]) st exp_hashlen prefix
        else (yy466 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy466 [@tailcall]) st exp_hashlen prefix
      )

and yy471 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  (yy472 [@tailcall]) st exp_hashlen prefix

and yy472 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  malformed_utf8 st

and yy473 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy465 [@tailcall]) st exp_hashlen prefix
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy467 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy473 [@tailcall]) st exp_hashlen prefix
        else (yy472 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy472 [@tailcall]) st exp_hashlen prefix
      )

and yy474 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy465 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy474 [@tailcall]) st exp_hashlen prefix
        else (yy472 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy472 [@tailcall]) st exp_hashlen prefix
      )

and yy475 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy502 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy475 [@tailcall]) st exp_hashlen prefix
        else (yy472 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy472 [@tailcall]) st exp_hashlen prefix
      )

and yy476 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy502 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy476 [@tailcall]) st exp_hashlen prefix
        else (yy472 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy472 [@tailcall]) st exp_hashlen prefix
      )

and yy477 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy503 [@tailcall]) st exp_hashlen prefix
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy504 [@tailcall]) st exp_hashlen prefix
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy502 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy477 [@tailcall]) st exp_hashlen prefix
        else (yy472 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy472 [@tailcall]) st exp_hashlen prefix
      )

and yy478 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy502 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy478 [@tailcall]) st exp_hashlen prefix
        else (yy472 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy472 [@tailcall]) st exp_hashlen prefix
      )

and yy479 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy502 [@tailcall]) st exp_hashlen prefix
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy505 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy479 [@tailcall]) st exp_hashlen prefix
        else (yy472 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy472 [@tailcall]) st exp_hashlen prefix
      )

and yy480 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy506 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy480 [@tailcall]) st exp_hashlen prefix
        else (yy472 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy472 [@tailcall]) st exp_hashlen prefix
      )

and yy481 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy506 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy481 [@tailcall]) st exp_hashlen prefix
        else (yy472 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy472 [@tailcall]) st exp_hashlen prefix
      )

and yy482 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy506 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy482 [@tailcall]) st exp_hashlen prefix
        else (yy472 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy472 [@tailcall]) st exp_hashlen prefix
      )

and yy483 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.t1 <- st.yyt1;
  st.t2 <- st.yyt2;
  st.yycursor <- st.yyt2;
  
    multiline_prefix_check st prefix;
    yyfnrmulti' st exp_hashlen prefix


and yy484 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy484 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        st.yyt2 <- st.yycursor;
        st.yycursor <- st.yycursor + 1;
        (yy483 [@tailcall]) st exp_hashlen prefix
      )
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy484 [@tailcall]) st exp_hashlen prefix
    | '\n'..'\x0C' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy486 [@tailcall]) st exp_hashlen prefix
    | '\r' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy488 [@tailcall]) st exp_hashlen prefix
    | '\xC2' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy489 [@tailcall]) st exp_hashlen prefix
    | '\xC3'..'\xDF' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy490 [@tailcall]) st exp_hashlen prefix
    | '\xE0' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy491 [@tailcall]) st exp_hashlen prefix
    | '\xE1' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy492 [@tailcall]) st exp_hashlen prefix
    | '\xE2' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy493 [@tailcall]) st exp_hashlen prefix
    | '\xE3' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy494 [@tailcall]) st exp_hashlen prefix
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy495 [@tailcall]) st exp_hashlen prefix
    | '\xED' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy496 [@tailcall]) st exp_hashlen prefix
    | '\xF0' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy497 [@tailcall]) st exp_hashlen prefix
    | '\xF1'..'\xF3' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy498 [@tailcall]) st exp_hashlen prefix
    | '\xF4' ->
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy499 [@tailcall]) st exp_hashlen prefix
    | _ -> (yy485 [@tailcall]) st exp_hashlen prefix

and yy485 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yycursor <- st.yymarker;
  match st.yyaccept with
    | 0 -> (yy468 [@tailcall]) st exp_hashlen prefix
    | 1 -> (yy466 [@tailcall]) st exp_hashlen prefix
    | 2 -> (yy472 [@tailcall]) st exp_hashlen prefix
    | _ -> (yy487 [@tailcall]) st exp_hashlen prefix

and yy486 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  (yy487 [@tailcall]) st exp_hashlen prefix

and yy487 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.t1 <- st.yyt1;
  st.yycursor <- st.yyt2;
  
    newline ~pos:st.t1 st;
    Buffer.add_char st.info.strbuf '\n';
    yyfnrmulti' st exp_hashlen prefix


and yy488 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy486 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy488 [@tailcall]) st exp_hashlen prefix
        else (yy487 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy487 [@tailcall]) st exp_hashlen prefix
      )

and yy489 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy483 [@tailcall]) st exp_hashlen prefix
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy486 [@tailcall]) st exp_hashlen prefix
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy484 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy489 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy490 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy483 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy490 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy491 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy490 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy491 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy492 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy490 [@tailcall]) st exp_hashlen prefix
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy507 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy492 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy493 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy508 [@tailcall]) st exp_hashlen prefix
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy509 [@tailcall]) st exp_hashlen prefix
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy490 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy493 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy494 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy507 [@tailcall]) st exp_hashlen prefix
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy490 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy494 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy495 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy490 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy495 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy496 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy490 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy496 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy497 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy495 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy497 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy498 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy495 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy498 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy499 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy495 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy499 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy500 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yyaccept <- 3;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '!'..'\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy500 [@tailcall]) st exp_hashlen prefix
        else (yy487 [@tailcall]) st exp_hashlen prefix
      ) else (
        st.yyt1 <- st.yycursor;
        st.yyt2 <- st.yycursor;
        st.yycursor <- st.yycursor + 1;
        (yy483 [@tailcall]) st exp_hashlen prefix
      )
    | '\t'
    | ' ' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy484 [@tailcall]) st exp_hashlen prefix
    | '\n'..'\x0C' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy486 [@tailcall]) st exp_hashlen prefix
    | '\r' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy488 [@tailcall]) st exp_hashlen prefix
    | '\xC2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy489 [@tailcall]) st exp_hashlen prefix
    | '\xC3'..'\xDF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy490 [@tailcall]) st exp_hashlen prefix
    | '\xE0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy491 [@tailcall]) st exp_hashlen prefix
    | '\xE1' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy492 [@tailcall]) st exp_hashlen prefix
    | '\xE2' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy493 [@tailcall]) st exp_hashlen prefix
    | '\xE3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy494 [@tailcall]) st exp_hashlen prefix
    | '\xE4'..'\xEC'
    | '\xEE'..'\xEF' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy495 [@tailcall]) st exp_hashlen prefix
    | '\xED' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy496 [@tailcall]) st exp_hashlen prefix
    | '\xF0' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy497 [@tailcall]) st exp_hashlen prefix
    | '\xF1'..'\xF3' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy498 [@tailcall]) st exp_hashlen prefix
    | '\xF4' ->
      st.yyt1 <- st.yycursor;
      st.yyt2 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy499 [@tailcall]) st exp_hashlen prefix
    | _ -> (yy487 [@tailcall]) st exp_hashlen prefix

and yy501 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy510 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy501 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy502 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy465 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy502 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy503 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8D'
    | '\x90'..'\xA7'
    | '\xAF'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy465 [@tailcall]) st exp_hashlen prefix
    | '\x8E'..'\x8F'
    | '\xAA'..'\xAE' ->
      st.yycursor <- st.yycursor + 1;
      (yy464 [@tailcall]) st exp_hashlen prefix
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy467 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy503 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy504 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy465 [@tailcall]) st exp_hashlen prefix
    | '\xA6'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy464 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy504 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy505 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy465 [@tailcall]) st exp_hashlen prefix
    | '\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy464 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy505 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy506 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy502 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy506 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy507 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy484 [@tailcall]) st exp_hashlen prefix
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy483 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy507 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy508 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy484 [@tailcall]) st exp_hashlen prefix
    | '\x8B'..'\xA7'
    | '\xAA'..'\xAE'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy483 [@tailcall]) st exp_hashlen prefix
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy486 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy508 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy509 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy483 [@tailcall]) st exp_hashlen prefix
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy484 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy509 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy510 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '#' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy511 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy510 [@tailcall]) st exp_hashlen prefix
        else (yy485 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy485 [@tailcall]) st exp_hashlen prefix
      )

and yy511 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '#' ->
      st.yycursor <- st.yycursor + 1;
      (yy511 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy511 [@tailcall]) st exp_hashlen prefix
        else (yy512 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy512 [@tailcall]) st exp_hashlen prefix
      )

and yy512 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.t1 <- st.yyt1;
  
    if check_hashlen st exp_hashlen then begin
      RAW_STRING (multiline_contents st.info.strbuf)
    end else yyfnrmulti' st exp_hashlen prefix


and yy513 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  error st "Unterminated raw string"

and yyfnrmulti (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  (yy463 [@tailcall]) st exp_hashlen prefix

and yy514 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy514 [@tailcall]) st exp_hashlen prefix
        else (yy542 [@tailcall]) st exp_hashlen prefix
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy515 [@tailcall]) st exp_hashlen prefix
      )
    | '\t'
    | ' '..'!'
    | '#'..'~' ->
      st.yycursor <- st.yycursor + 1;
      (yy516 [@tailcall]) st exp_hashlen prefix
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy518 [@tailcall]) st exp_hashlen prefix
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy520 [@tailcall]) st exp_hashlen prefix
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy521 [@tailcall]) st exp_hashlen prefix
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy524 [@tailcall]) st exp_hashlen prefix
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy525 [@tailcall]) st exp_hashlen prefix
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy526 [@tailcall]) st exp_hashlen prefix
    | '\xE1'
    | '\xE3'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy527 [@tailcall]) st exp_hashlen prefix
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy528 [@tailcall]) st exp_hashlen prefix
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy529 [@tailcall]) st exp_hashlen prefix
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy530 [@tailcall]) st exp_hashlen prefix
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy531 [@tailcall]) st exp_hashlen prefix
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy532 [@tailcall]) st exp_hashlen prefix
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy533 [@tailcall]) st exp_hashlen prefix
    | _ ->
      st.yycursor <- st.yycursor + 1;
      (yy522 [@tailcall]) st exp_hashlen prefix

and yy515 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  error st "Illegal character"

and yy516 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  (yy517 [@tailcall]) st exp_hashlen prefix

and yy517 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  add_lexeme_to_buf st st.info.strbuf; yyfnrsingle' st exp_hashlen prefix

and yy518 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  (yy519 [@tailcall]) st exp_hashlen prefix

and yy519 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  newline st; error st "Unterminated raw string"

and yy520 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy518 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy520 [@tailcall]) st exp_hashlen prefix
        else (yy519 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy519 [@tailcall]) st exp_hashlen prefix
      )

and yy521 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '#' ->
      st.yyt1 <- st.yycursor;
      st.yycursor <- st.yycursor + 1;
      (yy534 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy521 [@tailcall]) st exp_hashlen prefix
        else (yy517 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy517 [@tailcall]) st exp_hashlen prefix
      )

and yy522 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  (yy523 [@tailcall]) st exp_hashlen prefix

and yy523 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  malformed_utf8 st

and yy524 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy516 [@tailcall]) st exp_hashlen prefix
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy518 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy524 [@tailcall]) st exp_hashlen prefix
        else (yy523 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy523 [@tailcall]) st exp_hashlen prefix
      )

and yy525 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy516 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy525 [@tailcall]) st exp_hashlen prefix
        else (yy523 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy523 [@tailcall]) st exp_hashlen prefix
      )

and yy526 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy536 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy526 [@tailcall]) st exp_hashlen prefix
        else (yy523 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy523 [@tailcall]) st exp_hashlen prefix
      )

and yy527 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy536 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy527 [@tailcall]) st exp_hashlen prefix
        else (yy523 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy523 [@tailcall]) st exp_hashlen prefix
      )

and yy528 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy538 [@tailcall]) st exp_hashlen prefix
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy539 [@tailcall]) st exp_hashlen prefix
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy536 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy528 [@tailcall]) st exp_hashlen prefix
        else (yy523 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy523 [@tailcall]) st exp_hashlen prefix
      )

and yy529 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy536 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy529 [@tailcall]) st exp_hashlen prefix
        else (yy523 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy523 [@tailcall]) st exp_hashlen prefix
      )

and yy530 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy536 [@tailcall]) st exp_hashlen prefix
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy540 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy530 [@tailcall]) st exp_hashlen prefix
        else (yy523 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy523 [@tailcall]) st exp_hashlen prefix
      )

and yy531 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy541 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy531 [@tailcall]) st exp_hashlen prefix
        else (yy523 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy523 [@tailcall]) st exp_hashlen prefix
      )

and yy532 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy541 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy532 [@tailcall]) st exp_hashlen prefix
        else (yy523 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy523 [@tailcall]) st exp_hashlen prefix
      )

and yy533 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy541 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy533 [@tailcall]) st exp_hashlen prefix
        else (yy523 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy523 [@tailcall]) st exp_hashlen prefix
      )

and yy534 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '#' ->
      st.yycursor <- st.yycursor + 1;
      (yy534 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy534 [@tailcall]) st exp_hashlen prefix
        else (yy535 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy535 [@tailcall]) st exp_hashlen prefix
      )

and yy535 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.t1 <- st.yyt1;
  
    if check_hashlen st exp_hashlen then
      RAW_STRING (Buffer.contents st.info.strbuf)
    else yyfnrsingle' st exp_hashlen prefix


and yy536 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy516 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy536 [@tailcall]) st exp_hashlen prefix
        else (yy537 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy537 [@tailcall]) st exp_hashlen prefix
      )

and yy537 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  st.yycursor <- st.yymarker;
  (yy523 [@tailcall]) st exp_hashlen prefix

and yy538 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8D'
    | '\x90'..'\xA7'
    | '\xAF'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy516 [@tailcall]) st exp_hashlen prefix
    | '\x8E'..'\x8F'
    | '\xAA'..'\xAE' ->
      st.yycursor <- st.yycursor + 1;
      (yy515 [@tailcall]) st exp_hashlen prefix
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy518 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy538 [@tailcall]) st exp_hashlen prefix
        else (yy537 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy537 [@tailcall]) st exp_hashlen prefix
      )

and yy539 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy516 [@tailcall]) st exp_hashlen prefix
    | '\xA6'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy515 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy539 [@tailcall]) st exp_hashlen prefix
        else (yy537 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy537 [@tailcall]) st exp_hashlen prefix
      )

and yy540 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy516 [@tailcall]) st exp_hashlen prefix
    | '\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy515 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy540 [@tailcall]) st exp_hashlen prefix
        else (yy537 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy537 [@tailcall]) st exp_hashlen prefix
      )

and yy541 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy536 [@tailcall]) st exp_hashlen prefix
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy541 [@tailcall]) st exp_hashlen prefix
        else (yy537 [@tailcall]) st exp_hashlen prefix
      ) else (
        (yy537 [@tailcall]) st exp_hashlen prefix
      )

and yy542 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  error st "Unterminated raw string"

and yyfnrsingle (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  (yy514 [@tailcall]) st exp_hashlen prefix

and yy462 (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  match st.yycond with
    | YYC_rmulti -> (yyfnrmulti [@tailcall]) st exp_hashlen prefix
    | YYC_rsingle -> (yyfnrsingle [@tailcall]) st exp_hashlen prefix

and raw_string_body (st : tokenizer_state) (exp_hashlen : int) (prefix : string) : token =
  (yy462 [@tailcall]) st exp_hashlen prefix



and yyfnrmulti' st a b = save_start_position st; yyfnrmulti st a b
and yyfnrsingle' st a b = save_start_position st; yyfnrsingle st a b
and raw_string st exp_hashlen prefix =
  save_start_position st;
  raw_string_body st exp_hashlen prefix

let raw_string_multiline st exp_hashlen =
  validate_multiline_start st;
  let prefix = detect_raw_multiline_string_prefix st exp_hashlen (make_lexing_end_pos st) in
  st.yycond <- YYC_rmulti;
  raw_string st exp_hashlen prefix

let raw_string_singleline st exp_hashlen =
  st.yycond <- YYC_rsingle;
  raw_string st exp_hashlen ""


let rec yy543 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00'
    | '\x01'..'\b'
    | '\x0E'..'\x1F'
    | '['
    | ']'
    | '\x7F' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy543 [@tailcall]) st
        else (yy691 [@tailcall]) st
      ) else (
        st.yycursor <- st.yycursor + 1;
        (yy544 [@tailcall]) st
      )
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy546 [@tailcall]) st
    | '\n'..'\x0C' ->
      st.yycursor <- st.yycursor + 1;
      (yy548 [@tailcall]) st
    | '\r' ->
      st.yycursor <- st.yycursor + 1;
      (yy550 [@tailcall]) st
    | '!'
    | '$'..'\''
    | '*'
    | ','
    | ':'
    | '<'
    | '>'..'Z'
    | '^'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy554 [@tailcall]) st
    | '#' ->
      st.yycursor <- st.yycursor + 1;
      (yy556 [@tailcall]) st
    | '(' ->
      st.yycursor <- st.yycursor + 1;
      (yy557 [@tailcall]) st
    | ')' ->
      st.yycursor <- st.yycursor + 1;
      (yy558 [@tailcall]) st
    | '+'
    | '-' ->
      st.yycursor <- st.yycursor + 1;
      (yy559 [@tailcall]) st
    | '.' ->
      st.yycursor <- st.yycursor + 1;
      (yy560 [@tailcall]) st
    | '/' ->
      st.yycursor <- st.yycursor + 1;
      (yy561 [@tailcall]) st
    | '0' ->
      st.yycursor <- st.yycursor + 1;
      (yy562 [@tailcall]) st
    | '1'..'9' ->
      st.yycursor <- st.yycursor + 1;
      (yy564 [@tailcall]) st
    | ';' ->
      st.yycursor <- st.yycursor + 1;
      (yy565 [@tailcall]) st
    | '=' ->
      st.yycursor <- st.yycursor + 1;
      (yy566 [@tailcall]) st
    | '\\' ->
      st.yycursor <- st.yycursor + 1;
      (yy567 [@tailcall]) st
    | '{' ->
      st.yycursor <- st.yycursor + 1;
      (yy568 [@tailcall]) st
    | '}' ->
      st.yycursor <- st.yycursor + 1;
      (yy569 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy572 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy573 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy574 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy575 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy576 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy577 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy578 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy579 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy580 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy581 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy582 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy583 [@tailcall]) st
    | _ ->
      st.yycursor <- st.yycursor + 1;
      (yy570 [@tailcall]) st

and yy544 (st : tokenizer_state) : token =
  (yy545 [@tailcall]) st

and yy545 (st : tokenizer_state) : token =
  error st "Illegal character"

and yy546 (st : tokenizer_state) : token =
  st.yyaccept <- 0;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\t'
    | ' ' ->
      st.yycursor <- st.yycursor + 1;
      (yy546 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy584 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy586 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy587 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy588 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy546 [@tailcall]) st
        else (yy547 [@tailcall]) st
      ) else (
        (yy547 [@tailcall]) st
      )

and yy547 (st : tokenizer_state) : token =
  main st

and yy548 (st : tokenizer_state) : token =
  (yy549 [@tailcall]) st

and yy549 (st : tokenizer_state) : token =
  newline st; NEWLINE

and yy550 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\n' ->
      st.yycursor <- st.yycursor + 1;
      (yy548 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy550 [@tailcall]) st
        else (yy549 [@tailcall]) st
      ) else (
        (yy549 [@tailcall]) st
      )

and yy551 (st : tokenizer_state) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  (yy552 [@tailcall]) st yych

and yy552 (st : tokenizer_state) (yych : char) : token =
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | '0'..':'
    | '<'
    | '>'..'Z'
    | '^'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy589 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy591 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy592 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy593 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy594 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy595 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy596 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy597 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy598 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy599 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy600 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy551 [@tailcall]) st
        else (yy553 [@tailcall]) st
      ) else (
        (yy553 [@tailcall]) st
      )

and yy553 (st : tokenizer_state) : token =
  
    IDENT_STRING (lexeme st)


and yy554 (st : tokenizer_state) : token =
  st.yyaccept <- 2;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy601 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy554 [@tailcall]) st
        else (yy555 [@tailcall]) st
      ) else (
        (yy555 [@tailcall]) st
      )

and yy555 (st : tokenizer_state) : token =
  Buffer.reset st.info.strbuf; string_singleline st

and yy556 (st : tokenizer_state) : token =
  st.yyaccept <- 3;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | '0'..':'
    | '<'
    | '>'..'Z'
    | '^'..'z'
    | '|'
    | '~'
    | '\xC2'..'\xF4' -> (yy603 [@tailcall]) st yych
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy605 [@tailcall]) st
    | '#' ->
      st.yycursor <- st.yycursor + 1;
      (yy607 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy556 [@tailcall]) st
        else (yy545 [@tailcall]) st
      ) else (
        (yy545 [@tailcall]) st
      )

and yy557 (st : tokenizer_state) : token =
  LPAREN

and yy558 (st : tokenizer_state) : token =
  RPAREN

and yy559 (st : tokenizer_state) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy559 [@tailcall]) st
        else (yy553 [@tailcall]) st
      ) else (
        (yy553 [@tailcall]) st
      )
    | '.' ->
      st.yycursor <- st.yycursor + 1;
      (yy560 [@tailcall]) st
    | '0' ->
      st.yycursor <- st.yycursor + 1;
      (yy562 [@tailcall]) st
    | '1'..'9' ->
      st.yycursor <- st.yycursor + 1;
      (yy564 [@tailcall]) st
    | _ -> (yy552 [@tailcall]) st yych

and yy560 (st : tokenizer_state) : token =
  st.yyaccept <- 1;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy560 [@tailcall]) st
        else (yy553 [@tailcall]) st
      ) else (
        (yy553 [@tailcall]) st
      )
    | '0'..'9' ->
      st.yycursor <- st.yycursor + 1;
      (yy620 [@tailcall]) st
    | _ -> (yy552 [@tailcall]) st yych

and yy561 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '*' ->
      st.yycursor <- st.yycursor + 1;
      (yy622 [@tailcall]) st
    | '-' ->
      st.yycursor <- st.yycursor + 1;
      (yy623 [@tailcall]) st
    | '/' ->
      st.yycursor <- st.yycursor + 1;
      (yy624 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy561 [@tailcall]) st
        else (yy545 [@tailcall]) st
      ) else (
        (yy545 [@tailcall]) st
      )

and yy562 (st : tokenizer_state) : token =
  st.yyaccept <- 4;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'-'
    | ':'
    | '<'
    | '>'..'D'
    | 'F'..'Z'
    | '^'
    | '`'..'a'
    | 'c'..'d'
    | 'f'..'n'
    | 'p'..'w'
    | 'y'..'z'
    | '|'
    | '~'
    | '\xC2'..'\xF4' -> (yy626 [@tailcall]) st yych
    | '.' ->
      st.yycursor <- st.yycursor + 1;
      (yy628 [@tailcall]) st
    | '0'..'9'
    | '_' ->
      st.yycursor <- st.yycursor + 1;
      (yy564 [@tailcall]) st
    | 'E'
    | 'e' ->
      st.yycursor <- st.yycursor + 1;
      (yy629 [@tailcall]) st
    | 'b' ->
      st.yycursor <- st.yycursor + 1;
      (yy630 [@tailcall]) st
    | 'o' ->
      st.yycursor <- st.yycursor + 1;
      (yy631 [@tailcall]) st
    | 'x' ->
      st.yycursor <- st.yycursor + 1;
      (yy632 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy562 [@tailcall]) st
        else (yy563 [@tailcall]) st
      ) else (
        (yy563 [@tailcall]) st
      )

and yy563 (st : tokenizer_state) : token =
  INTEGER (lexeme st)

and yy564 (st : tokenizer_state) : token =
  st.yyaccept <- 4;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'-'
    | ':'
    | '<'
    | '>'..'D'
    | 'F'..'Z'
    | '^'
    | '`'..'d'
    | 'f'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | '.' ->
      st.yycursor <- st.yycursor + 1;
      (yy628 [@tailcall]) st
    | '0'..'9'
    | '_' ->
      st.yycursor <- st.yycursor + 1;
      (yy564 [@tailcall]) st
    | 'E'
    | 'e' ->
      st.yycursor <- st.yycursor + 1;
      (yy629 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy633 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy635 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy636 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy637 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy638 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy639 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy640 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy641 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy642 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy643 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy644 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy564 [@tailcall]) st
        else (yy563 [@tailcall]) st
      ) else (
        (yy563 [@tailcall]) st
      )

and yy565 (st : tokenizer_state) : token =
  SEMI

and yy566 (st : tokenizer_state) : token =
  EQ

and yy567 (st : tokenizer_state) : token =
  line_cont st; main st

and yy568 (st : tokenizer_state) : token =
  LBRACE

and yy569 (st : tokenizer_state) : token =
  RBRACE

and yy570 (st : tokenizer_state) : token =
  (yy571 [@tailcall]) st

and yy571 (st : tokenizer_state) : token =
  malformed_utf8 st

and yy572 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | '\x85' ->
      st.yycursor <- st.yycursor + 1;
      (yy548 [@tailcall]) st
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy546 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy572 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy573 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy573 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy574 (st : tokenizer_state) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy574 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy575 (st : tokenizer_state) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy645 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy575 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy576 (st : tokenizer_state) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy646 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy647 [@tailcall]) st
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy576 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy577 (st : tokenizer_state) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy645 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy577 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy578 (st : tokenizer_state) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy578 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy579 (st : tokenizer_state) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy579 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy580 (st : tokenizer_state) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy648 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy580 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy581 (st : tokenizer_state) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy595 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy581 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy582 (st : tokenizer_state) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy595 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy582 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy583 (st : tokenizer_state) : token =
  st.yyaccept <- 5;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy595 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy583 [@tailcall]) st
        else (yy571 [@tailcall]) st
      ) else (
        (yy571 [@tailcall]) st
      )

and yy584 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0' ->
      st.yycursor <- st.yycursor + 1;
      (yy546 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy584 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy585 (st : tokenizer_state) : token =
  st.yycursor <- st.yymarker;
  match st.yyaccept with
    | 0 -> (yy547 [@tailcall]) st
    | 1 -> (yy553 [@tailcall]) st
    | 2 -> (yy555 [@tailcall]) st
    | 3 -> (yy545 [@tailcall]) st
    | 4 -> (yy563 [@tailcall]) st
    | 5 -> (yy571 [@tailcall]) st
    | 6 -> (yy604 [@tailcall]) st
    | 7 -> (yy606 [@tailcall]) st
    | 8 -> (yy621 [@tailcall]) st
    | 9 -> (yy627 [@tailcall]) st
    | _ -> (yy675 [@tailcall]) st

and yy586 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy649 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy586 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy587 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy650 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy651 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy587 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy588 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy649 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy588 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy589 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy589 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy590 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy590 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy591 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy591 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy592 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy652 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy592 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy593 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy653 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy654 [@tailcall]) st
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy593 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy594 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy652 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy594 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy595 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy595 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy596 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy596 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy597 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy590 [@tailcall]) st
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy655 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy597 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy598 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy595 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy598 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy599 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy595 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy599 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy600 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy595 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy600 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy601 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy656 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy601 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy602 (st : tokenizer_state) : token =
  st.yyaccept <- 6;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  (yy603 [@tailcall]) st yych

and yy603 (st : tokenizer_state) (yych : char) : token =
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | '0'..':'
    | '<'
    | '>'..'Z'
    | '^'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy602 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy608 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy609 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy610 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy611 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy612 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy613 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy614 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy615 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy616 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy617 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy618 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy619 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy602 [@tailcall]) st
        else (yy604 [@tailcall]) st
      ) else (
        (yy604 [@tailcall]) st
      )

and yy604 (st : tokenizer_state) : token =
  
    begin match lexeme st with
    | "#true" -> TRUE
    | "#false" -> FALSE
    | "#null" -> NULL
    | "#inf" -> FLOAT "inf"
    | "#-inf" -> FLOAT "-inf"
    | "#nan" -> FLOAT "nan"
    | k -> error st ("Unknown keyword " ^ k)
    end


and yy605 (st : tokenizer_state) : token =
  st.yyaccept <- 7;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy657 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy605 [@tailcall]) st
        else (yy606 [@tailcall]) st
      ) else (
        (yy606 [@tailcall]) st
      )

and yy606 (st : tokenizer_state) : token =
  st.t1 <- st.yycursor;
  st.t1 <- st.t1 - 1;
  
    let hashlen = st.t1 - st.yystart in
    Buffer.reset st.info.strbuf;
    raw_string_singleline st hashlen


and yy607 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy605 [@tailcall]) st
    | '#' ->
      st.yycursor <- st.yycursor + 1;
      (yy607 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy607 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy608 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy602 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy608 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy609 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy602 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy609 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy610 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy609 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy610 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy611 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy609 [@tailcall]) st
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy658 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy611 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy612 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy659 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy660 [@tailcall]) st
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy609 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy612 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy613 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy658 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy609 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy613 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy614 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy609 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy614 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy615 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy609 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy615 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy616 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy609 [@tailcall]) st
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy661 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy616 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy617 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy614 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy617 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy618 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy614 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy618 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy619 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy614 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy619 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy620 (st : tokenizer_state) : token =
  st.yyaccept <- 8;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | '0'..':'
    | '<'
    | '>'..'Z'
    | '^'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy620 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy662 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy663 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy664 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy665 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy666 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy667 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy668 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy669 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy670 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy671 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy672 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy673 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy620 [@tailcall]) st
        else (yy621 [@tailcall]) st
      ) else (
        (yy621 [@tailcall]) st
      )

and yy621 (st : tokenizer_state) : token =
  
    error st "Number-like identifiers are invalid and must be quoted"


and yy622 (st : tokenizer_state) : token =
  multiline_comment st 0; main st

and yy623 (st : tokenizer_state) : token =
  SLASHDASH

and yy624 (st : tokenizer_state) : token =
  singleline_comment st; NEWLINE

and yy625 (st : tokenizer_state) : token =
  st.yyaccept <- 9;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  (yy626 [@tailcall]) st yych

and yy626 (st : tokenizer_state) (yych : char) : token =
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | '0'..':'
    | '<'
    | '>'..'Z'
    | '^'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy633 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy635 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy636 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy637 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy638 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy639 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy640 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy641 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy642 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy643 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy644 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy625 [@tailcall]) st
        else (yy627 [@tailcall]) st
      ) else (
        (yy627 [@tailcall]) st
      )

and yy627 (st : tokenizer_state) : token =
  
    error st @@ sprintf "Invalid number literal %s" (lexeme st)


and yy628 (st : tokenizer_state) : token =
  st.yyaccept <- 9;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy628 [@tailcall]) st
        else (yy627 [@tailcall]) st
      ) else (
        (yy627 [@tailcall]) st
      )
    | '0'..'9' ->
      st.yycursor <- st.yycursor + 1;
      (yy674 [@tailcall]) st
    | _ -> (yy626 [@tailcall]) st yych

and yy629 (st : tokenizer_state) : token =
  st.yyaccept <- 9;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy629 [@tailcall]) st
        else (yy627 [@tailcall]) st
      ) else (
        (yy627 [@tailcall]) st
      )
    | '+'
    | '-' ->
      st.yycursor <- st.yycursor + 1;
      (yy676 [@tailcall]) st
    | '0'..'9' ->
      st.yycursor <- st.yycursor + 1;
      (yy677 [@tailcall]) st
    | _ -> (yy626 [@tailcall]) st yych

and yy630 (st : tokenizer_state) : token =
  st.yyaccept <- 9;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy630 [@tailcall]) st
        else (yy627 [@tailcall]) st
      ) else (
        (yy627 [@tailcall]) st
      )
    | '0'..'1' ->
      st.yycursor <- st.yycursor + 1;
      (yy678 [@tailcall]) st
    | _ -> (yy626 [@tailcall]) st yych

and yy631 (st : tokenizer_state) : token =
  st.yyaccept <- 9;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy631 [@tailcall]) st
        else (yy627 [@tailcall]) st
      ) else (
        (yy627 [@tailcall]) st
      )
    | '0'..'7' ->
      st.yycursor <- st.yycursor + 1;
      (yy679 [@tailcall]) st
    | _ -> (yy626 [@tailcall]) st yych

and yy632 (st : tokenizer_state) : token =
  st.yyaccept <- 9;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy632 [@tailcall]) st
        else (yy627 [@tailcall]) st
      ) else (
        (yy627 [@tailcall]) st
      )
    | '0'..'9'
    | 'A'..'F'
    | 'a'..'f' ->
      st.yycursor <- st.yycursor + 1;
      (yy680 [@tailcall]) st
    | _ -> (yy626 [@tailcall]) st yych

and yy633 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy633 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy634 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy634 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy635 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy635 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy636 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy681 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy636 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy637 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy682 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy683 [@tailcall]) st
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy637 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy638 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy681 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy638 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy639 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy639 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy640 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy640 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy641 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy684 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy641 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy642 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy639 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy642 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy643 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy639 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy643 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy644 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy639 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy644 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy645 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy546 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy645 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy646 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy546 [@tailcall]) st
    | '\x8B'..'\x8D'
    | '\x90'..'\xA7'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | '\x8E'..'\x8F'
    | '\xAA'..'\xAE' ->
      st.yycursor <- st.yycursor + 1;
      (yy544 [@tailcall]) st
    | '\xA8'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy548 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy646 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy647 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy546 [@tailcall]) st
    | '\xA6'..'\xA9' ->
      st.yycursor <- st.yycursor + 1;
      (yy544 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy647 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy648 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | '\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy685 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy648 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy649 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy546 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy649 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy650 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8A'
    | '\xAF' ->
      st.yycursor <- st.yycursor + 1;
      (yy546 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy650 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy651 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy546 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy651 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy652 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy652 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy653 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x8B'..'\x8D'
    | '\x90'..'\xA7'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy653 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy654 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy654 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy655 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy551 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy655 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy656 (st : tokenizer_state) : token =
  Buffer.reset st.info.strbuf; string_multiline st

and yy657 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '"' ->
      st.yycursor <- st.yycursor + 1;
      (yy686 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy657 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy658 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy602 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy658 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy659 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x8B'..'\x8D'
    | '\x90'..'\xA7'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy602 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy659 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy660 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy602 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy660 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy661 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy602 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy661 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy662 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x84'
    | '\x86'..'\x9F'
    | '\xA1'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy620 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy662 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy663 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy620 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy663 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy664 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\xA0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy663 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy664 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy665 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x99'
    | '\x9B'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy663 [@tailcall]) st
    | '\x9A' ->
      st.yycursor <- st.yycursor + 1;
      (yy687 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy665 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy666 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy688 [@tailcall]) st
    | '\x81' ->
      st.yycursor <- st.yycursor + 1;
      (yy689 [@tailcall]) st
    | '\x82'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy663 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy666 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy667 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80' ->
      st.yycursor <- st.yycursor + 1;
      (yy687 [@tailcall]) st
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy663 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy667 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy668 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy663 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy668 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy669 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9F' ->
      st.yycursor <- st.yycursor + 1;
      (yy663 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy669 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy670 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBA'
    | '\xBC'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy663 [@tailcall]) st
    | '\xBB' ->
      st.yycursor <- st.yycursor + 1;
      (yy690 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy670 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy671 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x90'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy668 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy671 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy672 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy668 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy672 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy673 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x8F' ->
      st.yycursor <- st.yycursor + 1;
      (yy668 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy673 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy674 (st : tokenizer_state) : token =
  st.yyaccept <- 10;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | ':'
    | '<'
    | '>'..'D'
    | 'F'..'Z'
    | '^'
    | '`'..'d'
    | 'f'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | '0'..'9'
    | '_' ->
      st.yycursor <- st.yycursor + 1;
      (yy674 [@tailcall]) st
    | 'E'
    | 'e' ->
      st.yycursor <- st.yycursor + 1;
      (yy629 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy633 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy635 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy636 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy637 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy638 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy639 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy640 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy641 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy642 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy643 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy644 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy674 [@tailcall]) st
        else (yy675 [@tailcall]) st
      ) else (
        (yy675 [@tailcall]) st
      )

and yy675 (st : tokenizer_state) : token =
  FLOAT (lexeme st)

and yy676 (st : tokenizer_state) : token =
  st.yyaccept <- 9;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x00' ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy676 [@tailcall]) st
        else (yy627 [@tailcall]) st
      ) else (
        (yy627 [@tailcall]) st
      )
    | '0'..'9' ->
      st.yycursor <- st.yycursor + 1;
      (yy677 [@tailcall]) st
    | _ -> (yy626 [@tailcall]) st yych

and yy677 (st : tokenizer_state) : token =
  st.yyaccept <- 10;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | ':'
    | '<'
    | '>'..'Z'
    | '^'
    | '`'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | '0'..'9'
    | '_' ->
      st.yycursor <- st.yycursor + 1;
      (yy677 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy633 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy635 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy636 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy637 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy638 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy639 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy640 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy641 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy642 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy643 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy644 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy677 [@tailcall]) st
        else (yy675 [@tailcall]) st
      ) else (
        (yy675 [@tailcall]) st
      )

and yy678 (st : tokenizer_state) : token =
  st.yyaccept <- 4;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | '2'..':'
    | '<'
    | '>'..'Z'
    | '^'
    | '`'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | '0'..'1'
    | '_' ->
      st.yycursor <- st.yycursor + 1;
      (yy678 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy633 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy635 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy636 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy637 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy638 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy639 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy640 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy641 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy642 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy643 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy644 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy678 [@tailcall]) st
        else (yy563 [@tailcall]) st
      ) else (
        (yy563 [@tailcall]) st
      )

and yy679 (st : tokenizer_state) : token =
  st.yyaccept <- 4;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | '8'..':'
    | '<'
    | '>'..'Z'
    | '^'
    | '`'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | '0'..'7'
    | '_' ->
      st.yycursor <- st.yycursor + 1;
      (yy679 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy633 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy635 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy636 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy637 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy638 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy639 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy640 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy641 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy642 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy643 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy644 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy679 [@tailcall]) st
        else (yy563 [@tailcall]) st
      ) else (
        (yy563 [@tailcall]) st
      )

and yy680 (st : tokenizer_state) : token =
  st.yyaccept <- 4;
  st.yymarker <- st.yycursor;
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '!'
    | '$'..'\''
    | '*'..'.'
    | ':'
    | '<'
    | '>'..'@'
    | 'G'..'Z'
    | '^'
    | '`'
    | 'g'..'z'
    | '|'
    | '~' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | '0'..'9'
    | 'A'..'F'
    | '_'
    | 'a'..'f' ->
      st.yycursor <- st.yycursor + 1;
      (yy680 [@tailcall]) st
    | '\xC2' ->
      st.yycursor <- st.yycursor + 1;
      (yy633 [@tailcall]) st
    | '\xC3'..'\xDF' ->
      st.yycursor <- st.yycursor + 1;
      (yy634 [@tailcall]) st
    | '\xE0' ->
      st.yycursor <- st.yycursor + 1;
      (yy635 [@tailcall]) st
    | '\xE1' ->
      st.yycursor <- st.yycursor + 1;
      (yy636 [@tailcall]) st
    | '\xE2' ->
      st.yycursor <- st.yycursor + 1;
      (yy637 [@tailcall]) st
    | '\xE3' ->
      st.yycursor <- st.yycursor + 1;
      (yy638 [@tailcall]) st
    | '\xE4'..'\xEC'
    | '\xEE' ->
      st.yycursor <- st.yycursor + 1;
      (yy639 [@tailcall]) st
    | '\xED' ->
      st.yycursor <- st.yycursor + 1;
      (yy640 [@tailcall]) st
    | '\xEF' ->
      st.yycursor <- st.yycursor + 1;
      (yy641 [@tailcall]) st
    | '\xF0' ->
      st.yycursor <- st.yycursor + 1;
      (yy642 [@tailcall]) st
    | '\xF1'..'\xF3' ->
      st.yycursor <- st.yycursor + 1;
      (yy643 [@tailcall]) st
    | '\xF4' ->
      st.yycursor <- st.yycursor + 1;
      (yy644 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy680 [@tailcall]) st
        else (yy563 [@tailcall]) st
      ) else (
        (yy563 [@tailcall]) st
      )

and yy681 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy681 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy682 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x8B'..'\x8D'
    | '\x90'..'\xA7'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy682 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy683 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy683 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy684 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy625 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy684 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy685 (st : tokenizer_state) : token =
  BOM

and yy686 (st : tokenizer_state) : token =
  st.t1 <- st.yycursor;
  st.t1 <- st.t1 - 3;
  
    let hashlen = st.t1 - st.yystart in
    Buffer.reset st.info.strbuf;
    raw_string_multiline st hashlen


and yy687 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x81'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy620 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy687 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy688 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x8B'..'\x8D'
    | '\x90'..'\xA7'
    | '\xB0'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy620 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy688 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy689 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\x9E'
    | '\xA0'..'\xA5'
    | '\xAA'..'\xBF' ->
      st.yycursor <- st.yycursor + 1;
      (yy620 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy689 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy690 (st : tokenizer_state) : token =
  let yych = Bytes.unsafe_get st.yyinput st.yycursor in
  match yych with
    | '\x80'..'\xBE' ->
      st.yycursor <- st.yycursor + 1;
      (yy620 [@tailcall]) st
    | _ ->
      if (st.yylimit <= st.yycursor) then (
        if (st.refill st) then (yy690 [@tailcall]) st
        else (yy585 [@tailcall]) st
      ) else (
        (yy585 [@tailcall]) st
      )

and yy691 (st : tokenizer_state) : token =
  EOF

and main_body (st : tokenizer_state) : token =
  (yy543 [@tailcall]) st



and main st =
  save_token_position st;
  save_start_position st;
  main_body st

let main_tokenizer st =
  let lexer () =
    let token = main st in
    let start_pos, end_pos = get_location st in
    token, start_pos, end_pos
  in
  lexer
